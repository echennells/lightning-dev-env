name: Test Lightning Channel and Payments

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  test-lightning-channels:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Start Bitcoin and Lightning nodes
      run: |
        docker compose up -d bitcoind litd-1 litd-2 lnd
        echo "Waiting for containers to start..."
        sleep 5

    - name: Wait for Bitcoin to be ready
      run: |
        echo "Waiting for Bitcoin node to start..."
        for i in {1..30}; do
          if docker compose exec -T bitcoind bitcoin-cli -regtest -rpcuser=lightning -rpcpassword=lightning getblockchaininfo 2>/dev/null; then
            echo "Bitcoin node is ready!"
            break
          fi
          echo "Attempt $i/30: Bitcoin not ready yet..."
          sleep 2
        done

    - name: Create Bitcoin wallet and mine blocks
      run: |
        echo "Creating Bitcoin wallet..."
        docker compose exec -T bitcoind bitcoin-cli -regtest -rpcuser=lightning -rpcpassword=lightning createwallet "test" || \
        docker compose exec -T bitcoind bitcoin-cli -regtest -rpcuser=lightning -rpcpassword=lightning loadwallet "test"
        
        echo "Getting new address..."
        ADDR=$(docker compose exec -T bitcoind bitcoin-cli -regtest -rpcuser=lightning -rpcpassword=lightning getnewaddress)
        echo "Address: $ADDR"
        
        echo "Mining 101 blocks..."
        docker compose exec -T bitcoind bitcoin-cli -regtest -rpcuser=lightning -rpcpassword=lightning generatetoaddress 101 $ADDR > /dev/null
        
        echo "Bitcoin balance:"
        docker compose exec -T bitcoind bitcoin-cli -regtest -rpcuser=lightning -rpcpassword=lightning getbalance

    - name: Setup litd-1 wallet
      run: |
        echo "Waiting for litd-1 to be responsive..."
        for i in {1..30}; do
          if docker compose exec -T litd-1 lncli --network=regtest getinfo 2>&1 | grep -q "identity_pubkey"; then
            echo "litd-1 is responding!"
            break
          fi
          echo "Attempt $i/30: litd-1 not ready yet..."
          sleep 2
        done
        
        echo "Creating litd-1 wallet..."
        docker compose exec -T litd-1 lncli --network=regtest create <<EOF || true
        password12345678
        password12345678
        n
        EOF
        
        echo "Unlocking litd-1 wallet..."
        docker compose exec -T litd-1 lncli --network=regtest unlock <<EOF || true
        password12345678
        EOF
        
        sleep 5

    - name: Setup litd-2 wallet
      run: |
        echo "Waiting for litd-2 to be responsive..."
        for i in {1..30}; do
          if docker compose exec -T litd-2 lncli --network=regtest --rpcserver=litd-2:10010 getinfo 2>&1 | grep -q "identity_pubkey"; then
            echo "litd-2 is responding!"
            break
          fi
          echo "Attempt $i/30: litd-2 not ready yet..."
          sleep 2
        done
        
        echo "Creating litd-2 wallet..."
        docker compose exec -T litd-2 lncli --network=regtest --rpcserver=litd-2:10010 create <<EOF || true
        password12345678
        password12345678
        n
        EOF
        
        echo "Unlocking litd-2 wallet..."
        docker compose exec -T litd-2 lncli --network=regtest --rpcserver=litd-2:10010 unlock <<EOF || true
        password12345678
        EOF
        
        sleep 5

    - name: Setup LND wallet
      run: |
        echo "Waiting for LND to be responsive..."
        for i in {1..30}; do
          if docker compose exec -T lnd lncli --network=regtest --rpcserver=lnd:10011 getinfo 2>&1 | grep -q "identity_pubkey"; then
            echo "LND is responding!"
            break
          fi
          echo "Attempt $i/30: LND not ready yet..."
          sleep 2
        done
        
        echo "Creating LND wallet..."
        docker compose exec -T lnd lncli --network=regtest --rpcserver=lnd:10011 create <<EOF || true
        password12345678
        password12345678
        n
        EOF
        
        echo "Unlocking LND wallet..."
        docker compose exec -T lnd lncli --network=regtest --rpcserver=lnd:10011 unlock <<EOF || true
        password12345678
        EOF
        
        sleep 5

    - name: Wait for nodes to sync
      run: |
        echo "Waiting for litd-1 to sync with blockchain..."
        for i in {1..30}; do
          INFO=$(docker compose exec -T litd-1 lncli --network=regtest getinfo 2>/dev/null || echo "{}")
          # Debug: show what we're getting on first attempt
          if [ "$i" -eq 1 ]; then
            echo "DEBUG: litd-1 getinfo output (first 500 chars):"
            echo "$INFO" | head -c 500
            echo ""
          fi
          # Check for either format of synced_to_chain
          if echo "$INFO" | grep -qE '"synced_to_chain":\s*true|"synced_to_chain": true'; then
            echo "‚úÖ litd-1 is synced!"
            break
          fi
          if [ "$i" -eq 30 ]; then
            echo "‚ö†Ô∏è litd-1 sync check timed out, but continuing (may already be synced)..."
            echo "Last getinfo output:"
            echo "$INFO"
          else
            echo "Attempt $i/30: Waiting for sync..."
          fi
          sleep 2
        done
        
        echo -e "\nWaiting for litd-2 to sync with blockchain..."
        for i in {1..30}; do
          INFO=$(docker compose exec -T litd-2 lncli --network=regtest --rpcserver=litd-2:10010 getinfo 2>/dev/null || echo "{}")
          if [ "$i" -eq 1 ]; then
            echo "DEBUG: litd-2 getinfo output (first 500 chars):"
            echo "$INFO" | head -c 500
            echo ""
          fi
          if echo "$INFO" | grep -qE '"synced_to_chain":\s*true|"synced_to_chain": true'; then
            echo "‚úÖ litd-2 is synced!"
            break
          fi
          if [ "$i" -eq 30 ]; then
            echo "‚ö†Ô∏è litd-2 sync check timed out, but continuing..."
          else
            echo "Attempt $i/30: Waiting for sync..."
          fi
          sleep 2
        done
        
        echo -e "\nWaiting for LND to sync with blockchain..."
        for i in {1..30}; do
          INFO=$(docker compose exec -T lnd lncli --network=regtest --rpcserver=lnd:10011 getinfo 2>/dev/null || echo "{}")
          if [ "$i" -eq 1 ]; then
            echo "DEBUG: LND getinfo output (first 500 chars):"
            echo "$INFO" | head -c 500
            echo ""
          fi
          if echo "$INFO" | grep -qE '"synced_to_chain":\s*true|"synced_to_chain": true'; then
            echo "‚úÖ LND is synced!"
            break
          fi
          if [ "$i" -eq 30 ]; then
            echo "‚ö†Ô∏è LND sync check timed out, but continuing..."
          else
            echo "Attempt $i/30: Waiting for sync..."
          fi
          sleep 2
        done
        
        echo "All nodes sync check complete, proceeding..."

    - name: Fund all three Lightning nodes
      run: |
        echo "Waiting a bit for nodes to stabilize..."
        sleep 10
        
        echo "Getting litd-1 deposit address..."
        LITD1_ADDR=$(docker compose exec -T litd-1 lncli --network=regtest newaddress p2wkh | jq -r .address)
        echo "litd-1 address: $LITD1_ADDR"
        
        echo "Getting litd-2 deposit address..."
        LITD2_ADDR=$(docker compose exec -T litd-2 lncli --network=regtest --rpcserver=litd-2:10010 newaddress p2wkh | jq -r .address)
        echo "litd-2 address: $LITD2_ADDR"
        
        echo "Getting LND deposit address..."
        LND_ADDR=$(docker compose exec -T lnd lncli --network=regtest --rpcserver=lnd:10011 newaddress p2wkh | jq -r .address)
        echo "LND address: $LND_ADDR"
        
        # Check if addresses were obtained successfully
        if [ -z "$LITD1_ADDR" ] || [ -z "$LITD2_ADDR" ] || [ -z "$LND_ADDR" ]; then
          echo "Failed to get node addresses. Checking container status..."
          docker compose ps
          echo "Checking litd-1 logs..."
          docker compose logs --tail=30 litd-1
          exit 1
        fi
        
        echo "Sending 10 BTC to litd-1..."
        if ! docker compose exec -T bitcoind bitcoin-cli -regtest -rpcuser=lightning -rpcpassword=lightning sendtoaddress $LITD1_ADDR 10; then
          echo "‚ùå Failed to send BTC to litd-1"
          exit 1
        fi
        
        echo "Sending 10 BTC to litd-2..."
        if ! docker compose exec -T bitcoind bitcoin-cli -regtest -rpcuser=lightning -rpcpassword=lightning sendtoaddress $LITD2_ADDR 10; then
          echo "‚ùå Failed to send BTC to litd-2"
          exit 1
        fi
        
        echo "Sending 10 BTC to LND..."
        if ! docker compose exec -T bitcoind bitcoin-cli -regtest -rpcuser=lightning -rpcpassword=lightning sendtoaddress $LND_ADDR 10; then
          echo "‚ùå Failed to send BTC to LND"
          exit 1
        fi
        
        echo "Mining blocks to confirm..."
        ADDR=$(docker compose exec -T bitcoind bitcoin-cli -regtest -rpcuser=lightning -rpcpassword=lightning getnewaddress)
        docker compose exec -T bitcoind bitcoin-cli -regtest -rpcuser=lightning -rpcpassword=lightning generatetoaddress 6 $ADDR > /dev/null
        
        sleep 3
        
        echo "litd-1 wallet balance:"
        docker compose exec -T litd-1 lncli --network=regtest walletbalance
        
        echo "litd-2 wallet balance:"
        docker compose exec -T litd-2 lncli --network=regtest --rpcserver=litd-2:10010 walletbalance
        
        echo "LND wallet balance:"
        docker compose exec -T lnd lncli --network=regtest --rpcserver=lnd:10011 walletbalance

    - name: Open regular channel from litd-1 to LND
      run: |
        echo "Getting LND node info..."
        LND_PUBKEY=$(docker compose exec -T lnd lncli --network=regtest --rpcserver=lnd:10011 getinfo | jq -r .identity_pubkey)
        echo "LND pubkey: $LND_PUBKEY"
        
        echo "Connecting litd-1 to LND..."
        docker compose exec -T litd-1 lncli --network=regtest connect ${LND_PUBKEY}@lnd:9737
        
        echo "Opening channel from litd-1 to LND (0.1 BTC capacity, 0.05 BTC on each side)..."
        if ! docker compose exec -T litd-1 lncli --network=regtest openchannel \
          --node_key=$LND_PUBKEY \
          --local_amt=10000000 \
          --push_amt=5000000; then
          echo "‚ùå Failed to open channel from litd-1 to LND"
          exit 1
        fi
        
        echo "Mining blocks to confirm channel..."
        ADDR=$(docker compose exec -T bitcoind bitcoin-cli -regtest -rpcuser=lightning -rpcpassword=lightning getnewaddress)
        docker compose exec -T bitcoind bitcoin-cli -regtest -rpcuser=lightning -rpcpassword=lightning generatetoaddress 6 $ADDR > /dev/null
        
        echo "Waiting for channel to be active..."
        for i in {1..30}; do
          PENDING=$(docker compose exec -T litd-1 lncli --network=regtest pendingchannels | jq '.pending_open_channels | length')
          if [ "$PENDING" = "0" ]; then
            echo "Channel is active!"
            break
          fi
          echo "Attempt $i/30: Channel still pending..."
          sleep 2
        done

    - name: Test Lightning payment
      run: |
        echo "=== Testing Lightning Channel and Payment ==="
        
        echo "Checking channel status on litd-1..."
        docker compose exec -T litd-1 lncli --network=regtest listchannels | jq '.channels[0] | {active: .active, capacity: .capacity, local_balance: .local_balance, remote_balance: .remote_balance}'
        
        echo -e "\nCreating invoice on LND for 1000 sats..."
        INVOICE=$(docker compose exec -T lnd lncli --network=regtest --rpcserver=lnd:10011 addinvoice --amt=1000 --memo="Test payment" | jq -r .payment_request)
        echo "Invoice created: ${INVOICE:0:60}..."
        
        echo -e "\nPaying invoice from litd-1..."
        docker compose exec -T litd-1 lncli --network=regtest payinvoice --pay_req=$INVOICE --force || echo "Payment attempt completed"
        
        echo -e "\nChecking final balances..."
        echo "litd-1 channel balance:"
        docker compose exec -T litd-1 lncli --network=regtest channelbalance | jq '.'
        
        echo "LND channel balance:"
        docker compose exec -T lnd lncli --network=regtest --rpcserver=lnd:10011 channelbalance | jq '.'
        
        echo -e "\n‚úÖ Lightning channel established successfully!"

    - name: Open additional satoshi channels for cross-node payments
      run: |
        echo "=== Opening additional channels for proper funding ==="
        
        # Get node pubkeys
        LND_PUBKEY=$(docker compose exec -T lnd lncli --network=regtest --rpcserver=lnd:10011 getinfo | jq -r .identity_pubkey)
        LITD1_PUBKEY=$(docker compose exec -T litd-1 lncli --network=regtest getinfo | jq -r .identity_pubkey)
        LITD2_PUBKEY=$(docker compose exec -T litd-2 lncli --network=regtest --rpcserver=localhost:10010 getinfo | jq -r .identity_pubkey)
        
        echo "Node pubkeys:"
        echo "  LND: $LND_PUBKEY"
        echo "  LITD1: $LITD1_PUBKEY" 
        echo "  LITD2: $LITD2_PUBKEY"
        
        # Channel 1: litd-2 to lnd (so litd-2 can fund LNBITS1)
        echo -e "\n1. Opening channel from litd-2 to LND..."
        docker compose exec -T litd-2 lncli --network=regtest --rpcserver=localhost:10010 connect ${LND_PUBKEY}@lnd:9737
        if ! docker compose exec -T litd-2 lncli --network=regtest --rpcserver=localhost:10010 openchannel \
          --node_key=$LND_PUBKEY \
          --local_amt=10000000 \
          --push_amt=5000000; then
          echo "‚ùå Failed to open channel from litd-2 to LND"
          exit 1
        fi
        
        # Channel 2: litd-1 to litd-2 (satoshi channel, separate from Taproot Asset channel)
        echo -e "\n2. Opening satoshi channel from litd-1 to litd-2..."
        docker compose exec -T litd-1 lncli --network=regtest connect ${LITD2_PUBKEY}@litd-2:9736
        if ! docker compose exec -T litd-1 lncli --network=regtest openchannel \
          --node_key=$LITD2_PUBKEY \
          --local_amt=10000000 \
          --push_amt=5000000; then
          echo "‚ùå Failed to open channel from litd-1 to litd-2"
          exit 1
        fi
        
        echo -e "\n3. Mining blocks to confirm all channels..."
        ADDR=$(docker compose exec -T bitcoind bitcoin-cli -regtest -rpcuser=lightning -rpcpassword=lightning getnewaddress)
        docker compose exec -T bitcoind bitcoin-cli -regtest -rpcuser=lightning -rpcpassword=lightning generatetoaddress 10 $ADDR > /dev/null
        
        echo -e "\n4. Waiting for all channels to be active..."
        sleep 15
        
        echo -e "\n5. Verifying all channel balances..."
        echo "litd-1 channels:"
        docker compose exec -T litd-1 lncli --network=regtest listchannels | jq '.channels[] | {remote_pubkey: .remote_pubkey, capacity: .capacity, local_balance: .local_balance, remote_balance: .remote_balance}'
        
        echo -e "\nlitd-2 channels:"
        docker compose exec -T litd-2 lncli --network=regtest --rpcserver=localhost:10010 listchannels | jq '.channels[] | {remote_pubkey: .remote_pubkey, capacity: .capacity, local_balance: .local_balance, remote_balance: .remote_balance}'
        
        echo -e "\nlnd channels:"
        docker compose exec -T lnd lncli --network=regtest --rpcserver=lnd:10011 listchannels | jq '.channels[] | {remote_pubkey: .remote_pubkey, capacity: .capacity, local_balance: .local_balance, remote_balance: .remote_balance}'
        
        echo -e "\n‚úÖ All satoshi channels ready for cross-node payments!"

    - name: Start and test LNbits instances
      run: |
        echo "Starting 3 LNbits instances connected to Lightning nodes..."
        docker compose up -d lnbits-1 lnbits-2 lnbits-3
        
        echo "Waiting for LNbits instances to start (this may take a while to download)..."
        sleep 10
        
        # Show initial startup logs to see extension installation
        echo -e "\n=== Waiting for extension installation to complete ==="
        echo "Extensions are installed asynchronously after startup..."
        
        # Wait for extensions to be installed (check logs for completion)
        for i in {1..30}; do
          if docker compose logs lnbits-1 2>&1 | grep -q "Installed Extensions"; then
            echo "‚úÖ Extensions installed!"
            docker compose logs lnbits-1 2>&1 | grep -E "Installed Extensions" -A 5
            break
          fi
          echo "Attempt $i/30: Waiting for extensions to install..."
          sleep 2
        done
        
        # Check container status
        echo -e "\n=== Container status after startup ==="
        docker compose ps | grep lnbits
        
        # Quick check if Lightning nodes are accessible from LNbits containers
        echo -e "\n=== Testing Lightning node connectivity from lnbits-1 ==="
        docker compose exec -T lnbits-1 sh -c "wget --spider https://litd-1:8080 2>&1 | head -5" || true
        
        # Check lnbits-1 (litd-1)
        echo -e "\n=== Checking lnbits-1 (litd-1) on port 5001 ==="
        
        # First check if container is running
        if ! docker compose ps lnbits-1 | grep -q "Up"; then
          echo "‚ùå lnbits-1 container is not running!"
          echo "Container logs:"
          docker compose logs --tail=50 lnbits-1
          exit 1
        fi
        
        for i in {1..60}; do
          # Use || true to prevent exit on curl failure
          HEALTH_RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" http://localhost:5001/api/v1/health 2>&1 || true)
          
          if echo "$HEALTH_RESPONSE" | grep -q "HTTP_CODE:200"; then
            echo "‚úÖ lnbits-1 API is healthy!"
            break
          elif echo "$HEALTH_RESPONSE" | grep -q "HTTP_CODE:307"; then
            echo "‚ö†Ô∏è lnbits-1 is redirecting (first_install?)"
            echo "Response: $HEALTH_RESPONSE"
            break
          elif echo "$HEALTH_RESPONSE" | grep -q "Connection refused\|Failed to connect"; then
            if [ $i -eq 1 ]; then
              echo "Connection refused - LNbits may still be starting..."
              echo "Container logs:"
              docker compose logs --tail=20 lnbits-1
            fi
          fi
          
          if [ $i -eq 1 ] || [ $i -eq 20 ] || [ $i -eq 40 ]; then
            echo "Attempt $i/60: Response: $HEALTH_RESPONSE"
            echo "Checking if container is still running..."
            docker compose ps lnbits-1
            
            # Check last few log lines
            echo "Recent logs:"
            docker compose logs --tail=5 lnbits-1 2>&1
          else
            echo "Attempt $i/60: Waiting for lnbits-1..."
          fi
          sleep 3
        done
        
        # Check lnbits-2 (litd-2)
        echo -e "\n=== Checking lnbits-2 (litd-2) on port 5002 ==="
        for i in {1..60}; do
          if curl -s http://localhost:5002/api/v1/health 2>/dev/null; then
            echo "lnbits-2 API is responding!"
            break
          fi
          echo "Attempt $i/60: Waiting for lnbits-2..."
          sleep 3
        done
        
        # Check lnbits-3 (lnd)
        echo -e "\n=== Checking lnbits-3 (lnd) on port 5003 ==="
        for i in {1..60}; do
          if curl -s http://localhost:5003/api/v1/health 2>/dev/null; then
            echo "lnbits-3 API is responding!"
            break
          fi
          echo "Attempt $i/60: Waiting for lnbits-3..."
          sleep 3
        done
        
        echo -e "\n=== Testing all LNbits APIs ==="
        
        echo "1. Check lnbits-1 (litd-1) system info:"
        curl -s http://localhost:5001/api/v1/health || echo "lnbits-1 health check failed"
        
        echo -e "\n2. Check lnbits-2 (litd-2) system info:"
        curl -s http://localhost:5002/api/v1/health || echo "lnbits-2 health check failed"
        
        echo -e "\n3. Check lnbits-3 (lnd) system info:"
        curl -s http://localhost:5003/api/v1/health || echo "lnbits-3 health check failed"
        
        echo -e "\n‚úÖ All 3 LNbits instances are running and connected to their Lightning nodes!"

    - name: Test Taproot Assets functionality
      run: |
        echo "=== Testing Taproot Assets Integration ==="
        
        echo "Checking Taproot Assets daemon status on litd-1..."
        docker compose exec -T litd-1 tapcli --network=regtest --rpcserver=localhost:10009 --tlscertpath=/root/.lnd/tls.cert --macaroonpath=/root/.tapd/data/regtest/admin.macaroon getinfo || echo "Taproot Assets daemon info"
        
        echo -e "\nChecking Taproot Assets daemon status on litd-2..."
        docker compose exec -T litd-2 tapcli --network=regtest --rpcserver=localhost:10010 --tlscertpath=/root/.lnd/tls.cert --macaroonpath=/root/.tapd/data/regtest/admin.macaroon getinfo || echo "Taproot Assets daemon info"
        
        echo -e "\nListing assets on litd-1 (should be empty for fresh setup)..."
        docker compose exec -T litd-1 tapcli --network=regtest --rpcserver=localhost:10009 --tlscertpath=/root/.lnd/tls.cert --macaroonpath=/root/.tapd/data/regtest/admin.macaroon assets list || echo "No assets yet"
        
        echo -e "\nChecking universe stats on litd-1..."
        docker compose exec -T litd-1 tapcli --network=regtest --rpcserver=localhost:10009 --tlscertpath=/root/.lnd/tls.cert --macaroonpath=/root/.tapd/data/regtest/admin.macaroon universe stats || echo "Universe stats"
        
        echo -e "\nVerifying RFQ and oracle configuration in logs..."
        docker compose logs litd-1 | grep -i "rfq\|oracle\|taproot" | head -10 || echo "Checking Taproot logs"
        
        echo -e "\n‚úÖ Both Lightning Terminal nodes have full Taproot Assets support!"

    - name: Mint Taproot Asset and Open Asset Channel
      run: |
        echo "=== Minting Taproot Asset and Opening Asset Channel ==="
        
        echo "1. Minting a new Taproot Asset on litd-1 (TestCoin with 1 million units)..."
        MINT_RESULT=$(docker compose exec -T litd-1 tapcli --network=regtest --rpcserver=localhost:10009 --tlscertpath=/root/.lnd/tls.cert --macaroonpath=/root/.tapd/data/regtest/admin.macaroon assets mint \
          --type normal \
          --name TestCoin \
          --supply 1000000 \
          --meta_bytes "546573742041737365740a" || echo "{}")
        
        echo "Mint initiated. Waiting for batch..."
        sleep 2
        
        echo -e "\n2. Finalizing the mint batch..."
        docker compose exec -T litd-1 tapcli --network=regtest --rpcserver=localhost:10009 --tlscertpath=/root/.lnd/tls.cert --macaroonpath=/root/.tapd/data/regtest/admin.macaroon assets mint finalize || echo "Finalizing batch"
        
        echo -e "\n3. Mining blocks to confirm the minting..."
        ADDR=$(docker compose exec -T bitcoind bitcoin-cli -regtest -rpcuser=lightning -rpcpassword=lightning getnewaddress)
        docker compose exec -T bitcoind bitcoin-cli -regtest -rpcuser=lightning -rpcpassword=lightning generatetoaddress 6 $ADDR > /dev/null
        
        echo "Waiting for asset to be confirmed..."
        sleep 5
        
        echo -e "\n4. Listing minted assets on litd-1..."
        ASSETS=$(docker compose exec -T litd-1 tapcli --network=regtest --rpcserver=localhost:10009 --tlscertpath=/root/.lnd/tls.cert --macaroonpath=/root/.tapd/data/regtest/admin.macaroon assets list)
        echo "$ASSETS"
        
        # Extract asset ID from the list
        ASSET_ID=$(echo "$ASSETS" | jq -r '.assets[0].asset_genesis.asset_id' 2>/dev/null || echo "")
        
        if [ -n "$ASSET_ID" ] && [ "$ASSET_ID" != "null" ]; then
          echo -e "\n‚úÖ Successfully minted asset with ID: $ASSET_ID"
          
          echo -e "\n5. Preparing for Taproot Asset channel..."
          echo "Since litd-2 doesn't know about the asset yet, we'll open a channel with assets from litd-1"
          echo "Asset balance on litd-1:"
          docker compose exec -T litd-1 tapcli --network=regtest --rpcserver=localhost:10009 --tlscertpath=/root/.lnd/tls.cert --macaroonpath=/root/.tapd/data/regtest/admin.macaroon assets balance
          
          echo -e "\n6. Connecting nodes and opening Taproot Asset channel..."
          LITD2_PUBKEY=$(docker compose exec -T litd-2 lncli --network=regtest --rpcserver=litd-2:10010 getinfo | jq -r .identity_pubkey)
          
          echo "Connecting litd-1 to litd-2..."
          docker compose exec -T litd-1 lncli --network=regtest connect ${LITD2_PUBKEY}@litd-2:9736 || true
          
          echo "Opening channel with 50,000 TestCoin units..."
          echo "Debug: ASSET_ID=$ASSET_ID"
          echo "Debug: LITD2_PUBKEY=$LITD2_PUBKEY"
          
          # Verify the asset exists and has balance
          echo "Verifying asset exists on litd-1..."
          ASSET_BALANCE=$(docker compose exec -T litd-1 tapcli --network=regtest --rpcserver=localhost:10009 --tlscertpath=/root/.lnd/tls.cert --macaroonpath=/root/.tapd/data/regtest/admin.macaroon assets balance | jq -r ".asset_balances[\"$ASSET_ID\"].balance" || echo "0")
          echo "Asset balance: $ASSET_BALANCE"
          
          if [ "$ASSET_BALANCE" -ge "50000" ]; then
            echo "Sufficient balance. Opening Taproot Asset channel..."
            
            echo "========================================="
            echo "ATTEMPTING TO OPEN TAPROOT ASSET CHANNEL"
            echo "========================================="
            echo "Asset ID: $ASSET_ID"
            echo "litd-2 pubkey: $LITD2_PUBKEY"
            echo "Asset amount: 50000"
            echo "litd-1 balance: $ASSET_BALANCE"
            
            # First verify litd-2 knows about the asset through universe sync
            echo "Syncing universe to ensure litd-2 knows about the asset..."
            docker compose exec -T litd-2 tapcli --network=regtest --rpcserver=localhost:10010 --tlscertpath=/root/.lnd/tls.cert --macaroonpath=/root/.tapd/data/regtest/admin.macaroon universe federation add --universe_host=litd-1:10009 || true
            sleep 2
            docker compose exec -T litd-2 tapcli --network=regtest --rpcserver=localhost:10010 --tlscertpath=/root/.lnd/tls.cert --macaroonpath=/root/.tapd/data/regtest/admin.macaroon universe sync --universe_host=litd-1:10009 --asset_id="$ASSET_ID" || true
            sleep 3
            
            echo "Checking if litd-2 knows about the asset..."
            docker compose exec -T litd-2 tapcli --network=regtest --rpcserver=localhost:10010 --tlscertpath=/root/.lnd/tls.cert --macaroonpath=/root/.tapd/data/regtest/admin.macaroon universe roots
            
            # Open the Taproot Asset channel
            echo -e "\n>>> RUNNING: litcli ln fundchannel --node_key $LITD2_PUBKEY --asset_amount 50000 --asset_id $ASSET_ID --sat_per_vbyte 5"
            
            docker compose exec -T litd-1 litcli --network=regtest ln fundchannel \
              --node_key "$LITD2_PUBKEY" \
              --asset_amount 50000 \
              --asset_id "$ASSET_ID" \
              --sat_per_vbyte 5 2>&1
            
            CHANNEL_RESULT=$?
            
            if [ $CHANNEL_RESULT -ne 0 ]; then
              echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
              echo "TAPROOT ASSET CHANNEL OPENING FAILED!"
              echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
              echo "Debugging info:"
              echo "Checking litd-1 logs for errors..."
              docker compose logs --tail=20 litd-1 | grep -i "error\|fail\|unable" || true
              echo "Checking litd-2 logs for errors..."
              docker compose logs --tail=20 litd-2 | grep -i "error\|fail\|unable" || true
              exit 1
            fi
            
            echo "‚úÖ Taproot Asset channel opening initiated!"
            
            echo "Mining blocks to confirm the funding transaction..."
            ADDR=$(docker compose exec -T bitcoind bitcoin-cli -regtest -rpcuser=lightning -rpcpassword=lightning getnewaddress)
            docker compose exec -T bitcoind bitcoin-cli -regtest -rpcuser=lightning -rpcpassword=lightning generatetoaddress 6 $ADDR > /dev/null
            
            echo "Waiting for channel to be confirmed..."
            sleep 5
          else
            echo "Insufficient asset balance. Have: $ASSET_BALANCE, Need: 50000"
          fi
          
          echo -e "\n7. Verifying Taproot Asset channel is active..."
          echo "Checking litd-1 channels:"
          docker compose exec -T litd-1 lncli --network=regtest listchannels
          
          echo -e "\nChecking for Taproot Asset channel specifically:"
          ASSET_CHANNEL=$(docker compose exec -T litd-1 lncli --network=regtest listchannels | jq ".channels[] | select(.remote_pubkey == \"$LITD2_PUBKEY\")")
          if [ -n "$ASSET_CHANNEL" ]; then
            echo "‚úÖ Found channel with litd-2!"
            echo "$ASSET_CHANNEL" | jq '.'
          else
            echo "‚ùå No channel found with litd-2!"
            echo "All channels:"
            docker compose exec -T litd-1 lncli --network=regtest listchannels | jq '.channels'
            exit 1
            exit 1
          fi
          
          echo -e "\n8. Checking asset balances after channel opening..."
          echo "litd-1 assets:"
          docker compose exec -T litd-1 tapcli --network=regtest --rpcserver=localhost:10009 --tlscertpath=/root/.lnd/tls.cert --macaroonpath=/root/.tapd/data/regtest/admin.macaroon assets balance || echo "No assets"
          
          echo -e "\nlitd-2 assets:"
          docker compose exec -T litd-2 tapcli --network=regtest --rpcserver=localhost:10010 --tlscertpath=/root/.lnd/tls.cert --macaroonpath=/root/.tapd/data/regtest/admin.macaroon assets balance || echo "No assets"
          
          echo -e "\nlitd-1 channels:"
          docker compose exec -T litd-1 lncli --network=regtest listchannels | jq '.channels[] | {remote_pubkey: .remote_pubkey, capacity: .capacity, asset_id: .asset_id}'
          
          echo -e "\nChecking if asset was synced to litd-2's universe:"
          docker compose exec -T litd-2 tapcli --network=regtest --rpcserver=localhost:10010 --tlscertpath=/root/.lnd/tls.cert --macaroonpath=/root/.tapd/data/regtest/admin.macaroon universe roots || echo "Universe check"
          
          echo -e "\n‚úÖ Taproot Asset minted and channel opened!"
          
          echo "========================================="
          echo "TESTING TAPROOT ASSET TRANSFER"
          echo "========================================="
          
          # Wait for channel to be fully active
          echo "Waiting for channel to be fully active..."
          sleep 5
          
          # First, send some assets to litd-2 on-chain so it can create invoices
          echo "Sending some assets to litd-2 on-chain so it can receive via Lightning..."
          echo "Creating address on litd-2 to receive assets..."
          LITD2_ASSET_ADDR=$(docker compose exec -T litd-2 tapcli --network=regtest --rpcserver=localhost:10010 --tlscertpath=/root/.lnd/tls.cert --macaroonpath=/root/.tapd/data/regtest/admin.macaroon addrs new --asset_id "$ASSET_ID" --amt 10000 | jq -r '.encoded')
          echo "litd-2 asset address: $LITD2_ASSET_ADDR"
          
          echo "Sending 10,000 units to litd-2 on-chain..."
          docker compose exec -T litd-1 tapcli --network=regtest --rpcserver=localhost:10009 --tlscertpath=/root/.lnd/tls.cert --macaroonpath=/root/.tapd/data/regtest/admin.macaroon assets send --addr "$LITD2_ASSET_ADDR"
          
          echo "Mining blocks to confirm on-chain transfer..."
          ADDR=$(docker compose exec -T bitcoind bitcoin-cli -regtest -rpcuser=lightning -rpcpassword=lightning getnewaddress)
          docker compose exec -T bitcoind bitcoin-cli -regtest -rpcuser=lightning -rpcpassword=lightning generatetoaddress 6 $ADDR > /dev/null
          sleep 5
          
          echo "Checking balances before Lightning payment..."
          echo "litd-1 balance:"
          LITD1_BEFORE=$(docker compose exec -T litd-1 tapcli --network=regtest --rpcserver=localhost:10009 --tlscertpath=/root/.lnd/tls.cert --macaroonpath=/root/.tapd/data/regtest/admin.macaroon assets balance | jq -r ".asset_balances[\"$ASSET_ID\"].balance")
          echo "  $LITD1_BEFORE units"
          
          echo "litd-2 balance:"
          LITD2_BEFORE=$(docker compose exec -T litd-2 tapcli --network=regtest --rpcserver=localhost:10010 --tlscertpath=/root/.lnd/tls.cert --macaroonpath=/root/.tapd/data/regtest/admin.macaroon assets balance | jq -r ".asset_balances[\"$ASSET_ID\"].balance")
          echo "  $LITD2_BEFORE units"
          
          # Wait for litd-2 to have the assets confirmed
          echo "Waiting for litd-2 to confirm received assets..."
          for i in {1..10}; do
            LITD2_BALANCE=$(docker compose exec -T litd-2 tapcli --network=regtest --rpcserver=localhost:10010 --tlscertpath=/root/.lnd/tls.cert --macaroonpath=/root/.tapd/data/regtest/admin.macaroon assets balance | jq -r ".asset_balances[\"$ASSET_ID\"].balance")
            if [ "$LITD2_BALANCE" != "null" ] && [ "$LITD2_BALANCE" -gt 0 ]; then
              echo "litd-2 now has $LITD2_BALANCE units"
              break
            fi
            echo "Attempt $i/10: Waiting for assets to appear on litd-2..."
            sleep 2
          done
          
          echo -e "\nCreating Taproot Asset invoice on litd-2 for 1000 units..."
          echo "Running: docker compose exec -T litd-2 litcli --rpcserver localhost:8444 ln addinvoice --asset_id=$ASSET_ID --asset_amount=1000"
          
          # litcli needs to connect to the Lightning Terminal port (8444 for litd-2)
          INVOICE_RESPONSE=$(docker compose exec -T litd-2 litcli \
            --rpcserver localhost:8444 \
            --tlscertpath /root/.lit/tls.cert \
            --macaroonpath /root/.lit/regtest/lit.macaroon \
            --network=regtest \
            ln addinvoice \
            --asset_id "$ASSET_ID" \
            --asset_amount 1000 \
            --memo "Test Taproot Asset payment" 2>&1 || true)
          
          echo "Full invoice response:"
          echo "$INVOICE_RESPONSE"
          
          # Show the accepted buy quote details
          echo -e "\nAccepted buy quote from invoice response:"
          echo "$INVOICE_RESPONSE" | jq '.accepted_buy_quote' || true
          
          # Check if it's an error message
          if echo "$INVOICE_RESPONSE" | grep -q "Error\|error\|failed"; then
            echo "‚ùå Invoice creation returned an error"
            echo "Let's check if litd-2 can see the assets:"
            exit 1
            docker compose exec -T litd-2 tapcli --network=regtest \
              --rpcserver=localhost:10010 \
              --tlscertpath=/root/.lnd/tls.cert \
              --macaroonpath=/root/.tapd/data/regtest/admin.macaroon \
              assets balance || true
            echo ""
            echo "Let's check litd-2's LN info:"
            docker compose exec -T litd-2 litcli \
              --rpcserver localhost:8444 \
              --tlscertpath /root/.lit/tls.cert \
              --macaroonpath /root/.lit/regtest/lit.macaroon \
              --network=regtest \
              ln getinfo || true
            exit 1
          fi
          
          ASSET_INVOICE=$(echo "$INVOICE_RESPONSE" | jq -r '.invoice_result.payment_request' 2>/dev/null || echo "")
          
          if [ -z "$ASSET_INVOICE" ] || [ "$ASSET_INVOICE" = "null" ]; then
            echo "‚ùå Failed to extract invoice from response. Response was:"
            echo "$INVOICE_RESPONSE"
            exit 1
          fi
          
          echo "Invoice created: ${ASSET_INVOICE:0:60}..."
          
          echo -e "\nPaying Taproot Asset invoice from litd-1..."
          
          # For direct Taproot Asset payment, we don't need RFQ
          echo ">>> RUNNING: litcli ln payinvoice --pay_req=<invoice> --asset_id=$ASSET_ID --force"
          echo "This is a direct Taproot Asset payment over the asset channel, no RFQ needed"
          
          docker compose exec -T litd-1 litcli \
            --rpcserver localhost:8443 \
            --tlscertpath /root/.lit/tls.cert \
            --macaroonpath /root/.lit/regtest/lit.macaroon \
            --network=regtest \
            ln payinvoice \
            --pay_req="$ASSET_INVOICE" \
            --asset_id="$ASSET_ID" \
            --force
          
          PAYMENT_RESULT=$?
          
          if [ $PAYMENT_RESULT -eq 0 ]; then
            echo "‚úÖ Payment succeeded!"
            
            echo -e "\nChecking balances after Lightning payment..."
            sleep 3
            
            echo "litd-1 total balance:"
            LITD1_AFTER=$(docker compose exec -T litd-1 tapcli --network=regtest --rpcserver=localhost:10009 --tlscertpath=/root/.lnd/tls.cert --macaroonpath=/root/.tapd/data/regtest/admin.macaroon assets balance | jq -r ".asset_balances[\"$ASSET_ID\"].balance")
            echo "  $LITD1_AFTER units (was $LITD1_BEFORE)"
            
            echo "litd-2 total balance:"
            LITD2_AFTER=$(docker compose exec -T litd-2 tapcli --network=regtest --rpcserver=localhost:10010 --tlscertpath=/root/.lnd/tls.cert --macaroonpath=/root/.tapd/data/regtest/admin.macaroon assets balance | jq -r ".asset_balances[\"$ASSET_ID\"].balance")
            echo "  $LITD2_AFTER units (was $LITD2_BEFORE)"
            
            # Check channel balances specifically
            echo -e "\nChecking Taproot Asset channel balances:"
            echo "litd-1 rfq peer accepted quotes:"
            docker compose exec -T litd-1 tapcli --network=regtest --rpcserver=localhost:10009 --tlscertpath=/root/.lnd/tls.cert --macaroonpath=/root/.tapd/data/regtest/admin.macaroon rfq peeracceptedquotes || true
            
            echo -e "\nlitd-2 rfq peer accepted quotes:"
            docker compose exec -T litd-2 tapcli --network=regtest --rpcserver=localhost:10010 --tlscertpath=/root/.lnd/tls.cert --macaroonpath=/root/.tapd/data/regtest/admin.macaroon rfq peeracceptedquotes || true
            
            echo -e "\nDecoding the invoice to check if it's a Taproot Asset invoice:"
            docker compose exec -T litd-1 lncli --network=regtest --rpcserver=localhost:10009 decodepayreq "$ASSET_INVOICE" | jq '.' || true
            
            # Calculate the difference
            LITD1_DIFF=$((LITD1_BEFORE - LITD1_AFTER))
            LITD2_DIFF=$((LITD2_AFTER - LITD2_BEFORE))
            
            echo -e "\nTransfer summary:"
            echo "  litd-1 sent: $LITD1_DIFF units"
            echo "  litd-2 received: $LITD2_DIFF units"
            
            if [ "$LITD1_DIFF" -gt 0 ] && [ "$LITD2_DIFF" -gt 0 ]; then
              echo -e "\nüéâ SUCCESS! Transferred $LITD2_DIFF Taproot Assets over Lightning!"
            else
              echo -e "\n‚ùå WARNING: Balances don't reflect expected transfer"
            fi
          else
            echo "‚ùå Payment failed!"
            echo "Checking litd-1 logs for payment errors..."
            docker compose logs --tail=20 litd-1 | grep -i "error\|fail" || true
            exit 1
            exit 1
          fi
          
          echo -e "\n‚úÖ Taproot Asset channel test complete!"
        else
          echo "‚ö†Ô∏è Asset minting may not have completed. This is expected if Taproot Assets daemon is still syncing."
          echo "Assets list output: $ASSETS"
        fi

    - name: Show logs on failure
      if: failure()
      run: |
        echo "=== Bitcoin logs ==="
        docker compose logs --tail=30 bitcoind
        echo -e "\n=== litd-1 logs ==="
        docker compose logs --tail=30 litd-1
        echo -e "\n=== litd-2 logs ==="
        docker compose logs --tail=30 litd-2
        echo -e "\n=== LND logs ==="
        docker compose logs --tail=30 lnd
        echo -e "\n=== LNbits logs (if started) ==="
        docker compose logs --tail=30 lnbits 2>/dev/null || true

    - name: Generate SSL certificates for HTTPS proxy
      if: success()
      run: |
        echo "=== Generating SSL certificates for GitHub Actions ==="
        
        # Check if certificates already exist
        if [ -f ssl/lnbits.crt ] && [ -f ssl/lnbits.key ]; then
          echo "‚úÖ SSL certificates already exist"
        else
          echo "Generating self-signed SSL certificates..."
          mkdir -p ssl
          
          # Generate self-signed certificate for lnbits.example.com
          openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
            -keyout ssl/lnbits.key \
            -out ssl/lnbits.crt \
            -subj "/C=US/ST=Test/L=Test/O=Test/CN=lnbits.example.com" \
            -addext "subjectAltName=DNS:lnbits.example.com,DNS:localhost"
          
          echo "‚úÖ SSL certificates generated"
        fi
        
        # Verify certificates
        echo "Certificate details:"
        openssl x509 -in ssl/lnbits.crt -text -noout | grep -E "Subject:|DNS:" || true

    - name: Create GitHub Actions nginx proxy config for all 3 LNbits
      if: success()
      run: |
        echo "=== Creating nginx proxy config for all 3 LNbits instances ==="
        
        # Create a single nginx config with 3 server blocks on different ports
        cat > github-proxy-nginx.conf << 'EOF'
        # Proxy for LNBITS1 on port 6443
        server {
            listen 6443 ssl;
            server_name localhost lnbits1.example.com;

            ssl_certificate /etc/ssl/certs/lnbits.crt;
            ssl_certificate_key /etc/ssl/certs/lnbits.key;
            ssl_protocols TLSv1.2 TLSv1.3;

            location / {
                proxy_pass http://host.docker.internal:5001;
                proxy_set_header Host lnbits1.example.com;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto https;
                proxy_set_header X-Forwarded-Host lnbits1.example.com;
            }
        }
        
        # Proxy for LNBITS2 on port 6444
        server {
            listen 6444 ssl;
            server_name localhost lnbits2.example.com;

            ssl_certificate /etc/ssl/certs/lnbits.crt;
            ssl_certificate_key /etc/ssl/certs/lnbits.key;
            ssl_protocols TLSv1.2 TLSv1.3;

            location / {
                proxy_pass http://host.docker.internal:5002;
                proxy_set_header Host lnbits2.example.com;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto https;
                proxy_set_header X-Forwarded-Host lnbits2.example.com;
            }
        }
        
        # Proxy for LNBITS3 on port 6445
        server {
            listen 6445 ssl;
            server_name localhost lnbits3.example.com;

            ssl_certificate /etc/ssl/certs/lnbits.crt;
            ssl_certificate_key /etc/ssl/certs/lnbits.key;
            ssl_protocols TLSv1.2 TLSv1.3;

            location / {
                proxy_pass http://host.docker.internal:5003;
                proxy_set_header Host lnbits3.example.com;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto https;
                proxy_set_header X-Forwarded-Host lnbits3.example.com;
            }
        }
        EOF
        
        echo "‚úÖ Created unified nginx config for all 3 LNbits instances"

    - name: Setup HTTPS proxy for all 3 LNbits instances
      if: success()
      run: |
        echo "=== Setting up HTTPS proxy for all 3 LNbits instances ==="
        echo "HTTPS proxy is REQUIRED for LNbits extensions to work properly!"
        echo "Extensions need HTTPS for LNURL generation and proper authentication."
        
        # Clean up any existing proxy
        docker stop github-lnbits-proxy 2>/dev/null || true
        docker rm github-lnbits-proxy 2>/dev/null || true
        
        # Start single nginx proxy with all 3 ports exposed
        docker run -d --name github-lnbits-proxy \
          -p 6443:6443 \
          -p 6444:6444 \
          -p 6445:6445 \
          --add-host=host.docker.internal:host-gateway \
          -v "$(pwd)/github-proxy-nginx.conf":/etc/nginx/conf.d/default.conf:ro \
          -v "$(pwd)/ssl":/etc/ssl/certs:ro \
          nginx:alpine
        
        echo "‚úÖ HTTPS proxy started with ports 6443, 6444, 6445"
        sleep 3
        
        # Test all proxy connections
        echo "Testing proxy connections..."
        for PORT in 6443 6444 6445; do
          echo "Testing port $PORT..."
          for i in {1..30}; do
            if curl -k -s https://localhost:$PORT/api/v1/health >/dev/null 2>&1; then
              echo "‚úÖ Port $PORT working"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "‚ùå Port $PORT failed after 30 attempts"
              echo "Checking proxy logs..."
              docker logs github-lnbits-proxy
              exit 1
            fi
            sleep 1
          done
        done
        
        echo "‚úÖ All proxy ports operational"

    - name: Setup all 3 LNbits instances with extensions
      if: success()
      run: |
        echo "=== Setting up all 3 LNbits instances and testing extensions ==="
        
        # IMPORTANT: LNbits Extension Authentication Pattern (from HAR analysis):
        # - Extension management (install/activate/enable): Authorization: Bearer <access_token>
        # - Extension functionality (creating links): X-API-KEY: <admin_key> via HTTPS proxy
        # - HTTPS proxy is REQUIRED for LNURL generation to work properly
        
        # Function to setup LNbits instance
        setup_lnbits_instance() {
          local PORT=$1
          local NAME=$2
          local PROXY_PORT=$3
          
          echo -e "\n=========================================="
          echo "Setting up $NAME on port $PORT"
          echo "=========================================="
          
          # Wait for instance to be ready
          echo "Waiting for $NAME to initialize..."
          for i in {1..30}; do
            if curl -s http://localhost:$PORT/api/v1/health >/dev/null 2>&1; then
              echo "‚úÖ $NAME is ready!"
              break
            fi
            echo "Attempt $i/30: Waiting for $NAME..."
            sleep 2
          done
          
          # Complete first install via HTTPS proxy
          echo "Completing first install for $NAME via HTTPS..."
          FIRST_INSTALL=$(curl -k -s -X PUT https://localhost:$PROXY_PORT/api/v1/auth/first_install \
            -H "Content-Type: application/json" \
            -d '{
              "username": "admin'$PORT'",
              "password": "password123", 
              "password_repeat": "password123"
            }')
          
          if echo "$FIRST_INSTALL" | jq -e '.access_token' > /dev/null; then
            ACCESS_TOKEN=$(echo "$FIRST_INSTALL" | jq -r '.access_token')
            echo "‚úÖ Admin user created for $NAME"
          else
            echo "‚ùå Admin creation failed for $NAME: $FIRST_INSTALL"
            return 1
          fi
          
          # Get wallet info via HTTPS
          USER_INFO=$(curl -k -s "https://localhost:$PROXY_PORT/api/v1/auth" -H "Authorization: Bearer $ACCESS_TOKEN")
          ADMIN_KEY=$(echo "$USER_INFO" | jq -r '.wallets[0].adminkey')
          INVOICE_KEY=$(echo "$USER_INFO" | jq -r '.wallets[0].inkey')
          WALLET_ID=$(echo "$USER_INFO" | jq -r '.wallets[0].id')
          USER_ID=$(echo "$USER_INFO" | jq -r '.id')
          echo "‚úÖ Admin key for $NAME: ${ADMIN_KEY:0:20}..."
          
          # Configure Extension Sources to include lnurlFlip manifest
          echo "Configuring Extension Sources for $NAME..."
          curl -k -s -X PUT "https://localhost:$PROXY_PORT/admin/api/v1/settings" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            -d '{
              "lnbits_extensions_manifests": [
                "https://raw.githubusercontent.com/lnbits/lnbits-extensions/main/extensions.json",
                "https://raw.githubusercontent.com/echennells/lnurlFlip/main/manifest.json"
              ]
            }' > /dev/null
          echo "‚úÖ Extension Sources configured for $NAME"
          
          # Install lnurlp extension via HTTPS
          echo "Installing lnurlp extension on $NAME..."
          curl -k -s -X POST https://localhost:$PROXY_PORT/api/v1/extension \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            -d '{"ext_id": "lnurlp", "archive": "https://github.com/lnbits/lnurlp/archive/refs/tags/v1.0.1.zip", "source_repo": "https://raw.githubusercontent.com/lnbits/lnbits-extensions/main/extensions.json", "version": "1.0.1"}' > /dev/null
          
          curl -k -s -X PUT "https://localhost:$PROXY_PORT/api/v1/extension/lnurlp/activate" -H "Authorization: Bearer $ACCESS_TOKEN" > /dev/null
          curl -k -s -X PUT "https://localhost:$PROXY_PORT/api/v1/extension/lnurlp/enable" -H "Authorization: Bearer $ACCESS_TOKEN" > /dev/null
          echo "‚úÖ lnurlp installed on $NAME"
          
          # Install withdraw extension via HTTPS
          echo "Installing withdraw extension on $NAME..."
          curl -k -s -X POST https://localhost:$PROXY_PORT/api/v1/extension \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            -d '{"ext_id": "withdraw", "archive": "https://github.com/lnbits/withdraw/archive/refs/tags/v1.0.1.zip", "source_repo": "https://raw.githubusercontent.com/lnbits/lnbits-extensions/main/extensions.json", "version": "1.0.1"}' > /dev/null
          
          curl -k -s -X PUT "https://localhost:$PROXY_PORT/api/v1/extension/withdraw/activate" -H "Authorization: Bearer $ACCESS_TOKEN" > /dev/null
          curl -k -s -X PUT "https://localhost:$PROXY_PORT/api/v1/extension/withdraw/enable" -H "Authorization: Bearer $ACCESS_TOKEN" > /dev/null
          echo "‚úÖ withdraw installed on $NAME"
          
          # Install lnurlFlip extension via HTTPS (using correct GitHub API format)
          echo "Installing lnurlFlip extension on $NAME..."
          INSTALL_RESP=$(curl -k -s -X POST https://localhost:$PROXY_PORT/api/v1/extension \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            -d '{"ext_id": "lnurlFlip", "archive": "https://api.github.com/repos/echennells/lnurlFlip/zipball/v0.1.1", "source_repo": "echennells/lnurlFlip", "version": "v0.1.1"}')
          
          ACTIVATE_RESP=$(curl -k -s -X PUT "https://localhost:$PROXY_PORT/api/v1/extension/lnurlFlip/activate" -H "Authorization: Bearer $ACCESS_TOKEN")
          
          ENABLE_RESP=$(curl -k -s -X PUT "https://localhost:$PROXY_PORT/api/v1/extension/lnurlFlip/enable" -H "Authorization: Bearer $ACCESS_TOKEN")
          
          # Check extension status
          EXT_STATUS=$(curl -k -s "https://localhost:$PROXY_PORT/api/v1/extensions" -H "Authorization: Bearer $ACCESS_TOKEN")
          
          echo "‚úÖ lnurlFlip installed on $NAME"

          # Install Taproot Assets extension for bug detection testing
          echo "Installing Taproot Assets extension on $NAME..."
          TAPROOT_INSTALL_RESP=$(curl -k -s -X POST https://localhost:$PROXY_PORT/api/v1/extension \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            -d '{"ext_id": "taproot_assets", "archive": "https://api.github.com/repos/echennells/taproot_assets/zipball/main", "source_repo": "echennells/taproot_assets", "version": "main"}' 2>/dev/null || echo "Extension install attempted")

          # Configure Taproot Assets extension
          echo "Configuring Taproot Assets extension..."

          # Wait for extension installation to complete
          sleep 3

          # Find where LNbits installed the extension and create proper config
          EXTENSION_DIR=$(sudo find /home/ubuntu/lnbits -name "taproot_assets" -type d 2>/dev/null | head -1)
          if [ -n "$EXTENSION_DIR" ]; then
            echo "Found extension directory: $EXTENSION_DIR"

            # Create CI-specific configuration for regtest network
            sudo tee "$EXTENSION_DIR/taproot_assets.conf" > /dev/null << 'CONFIG_EOF'
# Taproot Assets Extension Configuration for CI (regtest)

# TAPD connection settings for Docker LiT
TAPD_HOST=localhost:10009
TAPD_NETWORK=regtest

# Docker paths mapped to host
TAPD_TLS_CERT_PATH=/home/ubuntu/lightning-dev-env/docker-compose/data/litd-1/.lnd/tls.cert
TAPD_MACAROON_PATH=/home/ubuntu/lightning-dev-env/docker-compose/data/litd-1/.tapd/data/regtest/admin.macaroon

# LND connection settings
LND_REST_MACAROON=/home/ubuntu/lightning-dev-env/docker-compose/data/litd-1/.lnd/data/chain/bitcoin/regtest/admin.macaroon

# Fee settings
TAPD_DEFAULT_SAT_FEE=1
CONFIG_EOF
            echo "‚úÖ CI-specific configuration created for extension"
          else
            echo "‚ö†Ô∏è  Could not find taproot_assets extension directory"
          fi

          # Verify config file paths exist
          echo "Verifying configuration file paths..."
          ls -la /home/ubuntu/lightning-dev-env/docker-compose/data/litd-1/.lnd/tls.cert 2>/dev/null && echo "‚úÖ TLS cert found" || echo "‚ùå TLS cert missing"
          ls -la /home/ubuntu/lightning-dev-env/docker-compose/data/litd-1/.tapd/data/regtest/admin.macaroon 2>/dev/null && echo "‚úÖ TAPD macaroon found" || echo "‚ùå TAPD macaroon missing"
          ls -la /home/ubuntu/lightning-dev-env/docker-compose/data/litd-1/.lnd/data/chain/bitcoin/regtest/admin.macaroon 2>/dev/null && echo "‚úÖ LND macaroon found" || echo "‚ùå LND macaroon missing"

          curl -k -s -X PUT "https://localhost:$PROXY_PORT/api/v1/extension/taproot_assets/activate" -H "Authorization: Bearer $ACCESS_TOKEN" > /dev/null 2>&1 || true
          sleep 2  # Give configuration time to be read
          curl -k -s -X PUT "https://localhost:$PROXY_PORT/api/v1/extension/taproot_assets/enable" -H "Authorization: Bearer $ACCESS_TOKEN" > /dev/null 2>&1 || true

          # Check extension status after configuration
          EXT_STATUS_AFTER=$(curl -k -s "https://localhost:$PROXY_PORT/api/v1/extensions" -H "Authorization: Bearer $ACCESS_TOKEN" | jq -r '.extensions[] | select(.id=="taproot_assets") | .active')
          echo "Taproot Assets extension status: $EXT_STATUS_AFTER"

          echo "‚úÖ Taproot Assets extension configured and setup attempted on $NAME"

          # Create test links to prepare for later testing
          echo "Creating test links for later testing..."
          sleep 10  # Give extensions even more time to initialize, especially lnurlFlip
          
          # Create LNURL-P pay link for testing
          echo "Creating LNURL-P pay link..."
          # Use HTTPS proxy with correct port for each instance
          PAY_LINK=$(curl -k -s -X POST "https://localhost:$PROXY_PORT/lnurlp/api/v1/links" \
            -H "X-API-KEY: $ADMIN_KEY" \
            -H "Content-Type: application/json" \
            -d '{
              "description": "Test Pay Link",
              "min": 100,
              "max": 10000,
              "comment_chars": 255
            }')
          
          if echo "$PAY_LINK" | jq -e '.id' > /dev/null; then
            PAY_ID=$(echo "$PAY_LINK" | jq -r '.id')
            echo "‚úÖ LNURL-P link created: $PAY_ID"
          else
            echo "‚ùå LNURL-P link creation failed: $PAY_LINK"
            PAY_ID=""
          fi
          
          # Create withdraw link for testing (via HTTPS proxy for LNURL generation)
          echo "Creating withdraw link via HTTPS proxy..."
          # Use HTTPS proxy with correct port for each instance - X-API-KEY auth for functional APIs
          # IMPORTANT: Use HAR-discovered correct format for withdraw link payload
          WITHDRAW_LINK=$(curl -k -s -X POST "https://localhost:$PROXY_PORT/withdraw/api/v1/links" \
            -H "X-Api-Key: $ADMIN_KEY" \
            -H "Content-Type: application/json" \
            -d '{
              "is_unique": true,
              "use_custom": false,
              "title": "vouchers",
              "min_withdrawable": 2000,
              "wait_time": 1,
              "max_withdrawable": 2000,
              "uses": 10,
              "custom_url": null
            }')
          
          if echo "$WITHDRAW_LINK" | jq -e '.id' > /dev/null; then
            WITHDRAW_ID=$(echo "$WITHDRAW_LINK" | jq -r '.id')
            WITHDRAW_HASH=$(echo "$WITHDRAW_LINK" | jq -r '.unique_hash')
            WITHDRAW_LNURL=$(echo "$WITHDRAW_LINK" | jq -r '.lnurl')
            echo "‚úÖ Withdraw link created: $WITHDRAW_ID"
            echo "   LNURL: ${WITHDRAW_LNURL:0:50}..."
          else
            echo "‚ùå Withdraw link creation failed: $WITHDRAW_LINK"
            WITHDRAW_ID=""
            WITHDRAW_HASH=""
            WITHDRAW_LNURL=""
          fi
          
          # Create dedicated LNURL-P and withdraw links exclusively for lnurlFlip
          echo "Creating dedicated LNURL-P link for lnurlFlip..."
          FLIP_PAY_LINK=$(curl -k -s -X POST "https://localhost:$PROXY_PORT/lnurlp/api/v1/links" \
            -H "X-API-KEY: $ADMIN_KEY" \
            -H "Content-Type: application/json" \
            -d '{
              "description": "Flip Pay Link",
              "min": 100,
              "max": 10000,
              "comment_chars": 255
            }')
          
          if echo "$FLIP_PAY_LINK" | jq -e '.id' > /dev/null; then
            FLIP_PAY_ID=$(echo "$FLIP_PAY_LINK" | jq -r '.id')
            echo "‚úÖ Flip LNURL-P link created: $FLIP_PAY_ID"
          else
            echo "‚ùå Flip LNURL-P link creation failed: $FLIP_PAY_LINK"
            FLIP_PAY_ID=""
          fi
          
          echo "Creating dedicated withdraw link for lnurlFlip..."
          FLIP_WITHDRAW_LINK=$(curl -k -s -X POST "https://localhost:$PROXY_PORT/withdraw/api/v1/links" \
            -H "X-Api-Key: $ADMIN_KEY" \
            -H "Content-Type: application/json" \
            -d '{
              "is_unique": true,
              "use_custom": false,
              "title": "flip vouchers",
              "min_withdrawable": 100,
              "wait_time": 1,
              "max_withdrawable": 5000,
              "uses": 10,
              "custom_url": null
            }')
          
          if echo "$FLIP_WITHDRAW_LINK" | jq -e '.id' > /dev/null; then
            FLIP_WITHDRAW_ID=$(echo "$FLIP_WITHDRAW_LINK" | jq -r '.id')
            echo "‚úÖ Flip withdraw link created: $FLIP_WITHDRAW_ID"
          else
            echo "‚ùå Flip withdraw link creation failed: $FLIP_WITHDRAW_LINK"
            FLIP_WITHDRAW_ID=""
          fi

          # Create lnurlFlip link that combines pay and withdraw
          if [ -n "$FLIP_PAY_ID" ] && [ -n "$FLIP_WITHDRAW_ID" ]; then
            echo "Creating lnurlFlip link..."
            
            
            # Wait for lnurlFlip to be ready
            sleep 5
            
            FLIP_LINK=$(curl -k -s -X POST "https://localhost:$PROXY_PORT/lnurlFlip/api/v1/lnurlflip" \
              -H "X-API-KEY: $ADMIN_KEY" \
              -H "Content-Type: application/json" \
              -d "{
                \"name\": \"Test Flip $NAME\",
                \"wallet\": \"$WALLET_ID\",
                \"selectedLnurlp\": \"$FLIP_PAY_ID\",
                \"selectedLnurlw\": \"$FLIP_WITHDRAW_ID\"
              }")
            
            if echo "$FLIP_LINK" | jq -e '.id' > /dev/null; then
              FLIP_ID=$(echo "$FLIP_LINK" | jq -r '.id')
              echo "‚úÖ lnurlFlip link created: $FLIP_ID"
            else
              echo "‚ùå lnurlFlip link creation failed: $FLIP_LINK"
              FLIP_ID=""
            fi
          else
            echo "‚ùå Cannot create lnurlFlip - missing pay or withdraw IDs"
            FLIP_ID=""
          fi
          
          # Export variables for later use
          echo "export ${NAME}_ADMIN_KEY=$ADMIN_KEY" >> lnbits_keys.env
          echo "export ${NAME}_INVOICE_KEY=$INVOICE_KEY" >> lnbits_keys.env
          echo "export ${NAME}_WALLET_ID=$WALLET_ID" >> lnbits_keys.env
          echo "export ${NAME}_PAY_ID=$PAY_ID" >> lnbits_keys.env
          echo "export ${NAME}_WITHDRAW_ID=$WITHDRAW_ID" >> lnbits_keys.env
          echo "export ${NAME}_WITHDRAW_HASH=$WITHDRAW_HASH" >> lnbits_keys.env
          echo "export ${NAME}_WITHDRAW_LNURL=$WITHDRAW_LNURL" >> lnbits_keys.env
          echo "export ${NAME}_FLIP_ID=$FLIP_ID" >> lnbits_keys.env
        }
        
        # Setup all 3 instances with their HTTPS proxy ports
        setup_lnbits_instance 5001 "LNBITS1" 6443
        setup_lnbits_instance 5002 "LNBITS2" 6444
        setup_lnbits_instance 5003 "LNBITS3" 6445
        
        # Source the saved keys
        source lnbits_keys.env
        
        echo -e "\n‚úÖ All 3 LNbits instances configured with extensions!"

    - name: Fund LNbits wallets from Lightning nodes
      if: success()
      run: |
        echo "=== Funding LNbits wallets from Lightning node channels ==="
        
        # Source the saved keys
        source lnbits_keys.env
        
        echo -e "\nFunding LNBITS1 from litd-2 (cross-node)..."
        # Create an invoice on LNBITS1 for 500k sats
        FUNDING_INVOICE1=$(curl -s -X POST "http://localhost:5001/api/v1/payments" \
          -H "X-API-KEY: $LNBITS1_INVOICE_KEY" \
          -H "Content-Type: application/json" \
          -d '{"out": false, "amount": 500000, "memo": "Cross-node funding from litd-2"}')
        
        if echo "$FUNDING_INVOICE1" | jq -e '.bolt11' > /dev/null 2>&1; then
          BOLT11_FUND1=$(echo "$FUNDING_INVOICE1" | jq -r '.bolt11')
          echo "‚úÖ Funding invoice created for LNBITS1"
          
          # Pay from litd-2 (different node - should work via channel)
          echo "Paying from litd-2 Lightning node via channel..."
          PAYMENT_RESULT=$(docker compose exec -T litd-2 lncli --network=regtest --rpcserver=litd-2:10010 payinvoice --pay_req="$BOLT11_FUND1" --force 2>&1 || true)
          echo "Payment result: $PAYMENT_RESULT"
          
          # Check if payment was successful
          if echo "$PAYMENT_RESULT" | grep -q "Payment status: SUCCEEDED\|Payment completed successfully\|payment_hash"; then
            echo "‚úÖ Payment successful from litd-2 to LNBITS1"
          else
            echo "‚ùå Payment failed from litd-2 to LNBITS1"
            echo "   Error details: $PAYMENT_RESULT"
            exit 1
          fi
          sleep 2
        else
          echo "‚ùå Failed to create funding invoice for LNBITS1"
          exit 1
        fi
        
        echo -e "\nFunding LNBITS2 from lnd (cross-node)..."
        FUNDING_INVOICE2=$(curl -s -X POST "http://localhost:5002/api/v1/payments" \
          -H "X-API-KEY: $LNBITS2_INVOICE_KEY" \
          -H "Content-Type: application/json" \
          -d '{"out": false, "amount": 500000, "memo": "Cross-node funding from lnd"}')
        
        if echo "$FUNDING_INVOICE2" | jq -e '.bolt11' > /dev/null 2>&1; then
          BOLT11_FUND2=$(echo "$FUNDING_INVOICE2" | jq -r '.bolt11')
          echo "‚úÖ Funding invoice created for LNBITS2"
          
          echo "Paying from lnd Lightning node via channels..."
          PAYMENT_RESULT=$(docker compose exec -T lnd lncli --network=regtest --rpcserver=lnd:10011 payinvoice --pay_req="$BOLT11_FUND2" --force 2>&1 || true)
          echo "Payment result: $PAYMENT_RESULT"
          
          # Check if payment was successful
          if echo "$PAYMENT_RESULT" | grep -q "Payment status: SUCCEEDED\|Payment completed successfully\|payment_hash"; then
            echo "‚úÖ Payment successful from lnd to LNBITS2"
          else
            echo "‚ùå Payment failed from lnd to LNBITS2"
            echo "   Error details: $PAYMENT_RESULT"
            exit 1
          fi
          sleep 2
        else
          echo "‚ùå Failed to create funding invoice for LNBITS2"
          exit 1
        fi
        
        echo -e "\nFunding LNBITS3 from litd-1 (cross-node)..."
        FUNDING_INVOICE3=$(curl -s -X POST "http://localhost:5003/api/v1/payments" \
          -H "X-API-KEY: $LNBITS3_INVOICE_KEY" \
          -H "Content-Type: application/json" \
          -d '{"out": false, "amount": 500000, "memo": "Cross-node funding from litd-1"}')
        
        if echo "$FUNDING_INVOICE3" | jq -e '.bolt11' > /dev/null 2>&1; then
          BOLT11_FUND3=$(echo "$FUNDING_INVOICE3" | jq -r '.bolt11')
          echo "‚úÖ Funding invoice created for LNBITS3"
          
          echo "Paying from litd-1 Lightning node via channels..."
          PAYMENT_RESULT=$(docker compose exec -T litd-1 lncli --network=regtest payinvoice --pay_req="$BOLT11_FUND3" --force 2>&1 || true)
          if echo "$PAYMENT_RESULT" | grep -q "Payment status: SUCCEEDED\|payment succeeded\|successfully"; then
            echo "‚úÖ Successfully funded LNBITS3 from litd-1"
          else
            echo "‚ùå Payment failed from litd-1 to LNBITS3"
            echo "   Error details: $PAYMENT_RESULT"
            exit 1
          fi
          sleep 2
        else
          echo "‚ùå Failed to create funding invoice for LNBITS3"
          exit 1
        fi
        
        # Check balances after funding and verify success
        echo -e "\n=== Post-funding wallet balances ==="
        FUNDING_SUCCESS=0
        
        for port in 5001 5002 5003; do
          NAME="LNBITS$(($port - 5000))"
          KEY_VAR="${NAME}_INVOICE_KEY"
          KEY="${!KEY_VAR}"
          
          WALLET=$(curl -s "http://localhost:$port/api/v1/wallet" \
            -H "X-API-KEY: $KEY")
          
          if echo "$WALLET" | jq -e '.balance' > /dev/null 2>&1; then
            BALANCE=$(echo "$WALLET" | jq -r '.balance')
            echo "$NAME balance: $BALANCE msat"
            
            # Check if wallet was successfully funded (balance > 0)
            if [ "$BALANCE" -gt 0 ]; then
              echo "‚úÖ $NAME successfully funded"
              FUNDING_SUCCESS=$((FUNDING_SUCCESS + 1))
            else
              echo "‚ùå $NAME funding failed - balance is 0"
              exit 1
            fi
          else
            echo "$NAME: Failed to get balance"
            echo "‚ùå $NAME funding failed - cannot retrieve balance"
            exit 1
          fi
        done
        
        echo -e "\nFunding summary: $FUNDING_SUCCESS/3 wallets funded successfully"
        
        if [ $FUNDING_SUCCESS -eq 0 ]; then
          echo "üö® CRITICAL: No wallets were funded successfully!"
          echo "Cannot proceed with transaction tests without funded wallets"
          exit 1
        elif [ $FUNDING_SUCCESS -lt 3 ]; then
          echo "‚ö†Ô∏è  WARNING: Only $FUNDING_SUCCESS/3 wallets funded - some tests may fail"
        else
          echo "üéâ All wallets funded successfully!"
        fi


    - name: Test LNURL-P and Withdraw with Real Lightning Payments
      if: success()
      run: |
        echo "Testing LNURL-P and Withdraw with Real Payments"

        # Source the saved keys
        source lnbits_keys.env

        # Helper function to capture all channel balances
        capture_channel_balances() {
          local label="$1"
          echo "üìä Capturing channel balances: $label"

          # Get litd-1 channel balances and details
          LITD1_CHANNELS=$(docker compose exec -T litd-1 lncli --network=regtest listchannels)
          LITD1_LOCAL=$(echo "$LITD1_CHANNELS" | jq '[.channels[].local_balance | tonumber] | add')
          LITD1_REMOTE=$(echo "$LITD1_CHANNELS" | jq '[.channels[].remote_balance | tonumber] | add')
          LITD1_CAPACITY=$(echo "$LITD1_CHANNELS" | jq '[.channels[].capacity | tonumber] | add')
          LITD1_PENDING=$(echo "$LITD1_CHANNELS" | jq '[.channels[].pending_htlcs[].amount | tonumber] | add // 0')
          LITD1_ACTIVE_COUNT=$(echo "$LITD1_CHANNELS" | jq '[.channels[] | select(.active == true)] | length')
          LITD1_TOTAL_COUNT=$(echo "$LITD1_CHANNELS" | jq '.channels | length')

          # Get litd-2 channel balances and details
          LITD2_CHANNELS=$(docker compose exec -T litd-2 lncli --network=regtest --rpcserver=litd-2:10010 listchannels)
          LITD2_LOCAL=$(echo "$LITD2_CHANNELS" | jq '[.channels[].local_balance | tonumber] | add')
          LITD2_REMOTE=$(echo "$LITD2_CHANNELS" | jq '[.channels[].remote_balance | tonumber] | add')
          LITD2_CAPACITY=$(echo "$LITD2_CHANNELS" | jq '[.channels[].capacity | tonumber] | add')
          LITD2_PENDING=$(echo "$LITD2_CHANNELS" | jq '[.channels[].pending_htlcs[].amount | tonumber] | add // 0')
          LITD2_ACTIVE_COUNT=$(echo "$LITD2_CHANNELS" | jq '[.channels[] | select(.active == true)] | length')
          LITD2_TOTAL_COUNT=$(echo "$LITD2_CHANNELS" | jq '.channels | length')

          # Get LND channel balances and details
          LND_CHANNELS=$(docker compose exec -T lnd lncli --network=regtest --rpcserver=lnd:10011 listchannels)
          LND_LOCAL=$(echo "$LND_CHANNELS" | jq '[.channels[].local_balance | tonumber] | add')
          LND_REMOTE=$(echo "$LND_CHANNELS" | jq '[.channels[].remote_balance | tonumber] | add')
          LND_CAPACITY=$(echo "$LND_CHANNELS" | jq '[.channels[].capacity | tonumber] | add')
          LND_PENDING=$(echo "$LND_CHANNELS" | jq '[.channels[].pending_htlcs[].amount | tonumber] | add // 0')
          LND_ACTIVE_COUNT=$(echo "$LND_CHANNELS" | jq '[.channels[] | select(.active == true)] | length')
          LND_TOTAL_COUNT=$(echo "$LND_CHANNELS" | jq '.channels | length')

          echo "  litd-1: local=$LITD1_LOCAL, remote=$LITD1_REMOTE, capacity=$LITD1_CAPACITY, pending=$LITD1_PENDING, channels=$LITD1_ACTIVE_COUNT/$LITD1_TOTAL_COUNT"
          echo "  litd-2: local=$LITD2_LOCAL, remote=$LITD2_REMOTE, capacity=$LITD2_CAPACITY, pending=$LITD2_PENDING, channels=$LITD2_ACTIVE_COUNT/$LITD2_TOTAL_COUNT"
          echo "  lnd:    local=$LND_LOCAL, remote=$LND_REMOTE, capacity=$LND_CAPACITY, pending=$LND_PENDING, channels=$LND_ACTIVE_COUNT/$LND_TOTAL_COUNT"

          # Check for channel health issues
          check_channel_health() {
            local node_name="$1"
            local channels_json="$2"
            local issues=0

            # Check for inactive channels
            local inactive_count=$(echo "$channels_json" | jq '[.channels[] | select(.active == false)] | length')
            if [ "$inactive_count" -gt 0 ]; then
              echo "  ‚ö†Ô∏è $node_name: $inactive_count inactive channels detected"
              issues=$((issues + 1))
            fi

            # Check for channels with high pending HTLC count
            local htlc_channels=$(echo "$channels_json" | jq '.channels[] | select((.pending_htlcs | length) > 5)')
            if [ -n "$htlc_channels" ] && [ "$htlc_channels" != "null" ]; then
              echo "  ‚ö†Ô∏è $node_name: Channels with high HTLC count detected"
              issues=$((issues + 1))
            fi

            # Check for very low balances (less than 1000 sats)
            local low_balance_channels=$(echo "$channels_json" | jq '.channels[] | select(.local_balance < 1000)')
            if [ -n "$low_balance_channels" ] && [ "$low_balance_channels" != "null" ]; then
              echo "  ‚ö†Ô∏è $node_name: Channels with very low local balance detected"
              issues=$((issues + 1))
            fi

            return $issues
          }

          check_channel_health "litd-1" "$LITD1_CHANNELS"
          check_channel_health "litd-2" "$LITD2_CHANNELS"
          check_channel_health "lnd" "$LND_CHANNELS"
        }

        # Helper function to verify channel balance changes
        verify_channel_balance_changes() {
          local expected_amount="$1"
          local from_node="$2"
          local to_node="$3"

          echo "üîç Verifying channel balance changes for $expected_amount sats from $from_node to $to_node"

          # Compare before and after balances
          case "$from_node" in
            "litd-1")
              local_diff=$((LITD1_LOCAL_BEFORE - LITD1_LOCAL))
              remote_diff=$((LITD1_REMOTE - LITD1_REMOTE_BEFORE))
              ;;
            "litd-2")
              local_diff=$((LITD2_LOCAL_BEFORE - LITD2_LOCAL))
              remote_diff=$((LITD2_REMOTE - LITD2_REMOTE_BEFORE))
              ;;
            "lnd")
              local_diff=$((LND_LOCAL_BEFORE - LND_LOCAL))
              remote_diff=$((LND_REMOTE - LND_REMOTE_BEFORE))
              ;;
          esac

          echo "  Channel balance change for $from_node:"
          echo "    Local decreased by: $local_diff sats"
          echo "    Remote increased by: $remote_diff sats"

          # Allow for small fee differences (up to 100 sats)
          if [ "$local_diff" -ge $((expected_amount - 100)) ] && [ "$local_diff" -le $((expected_amount + 100)) ]; then
            echo "  ‚úÖ Channel balances correctly updated for $from_node"
            return 0
          else
            echo "  ‚ö†Ô∏è WARNING: Channel balance change doesn't match expected amount!"
            echo "    Expected: ~$expected_amount sats, Got: $local_diff sats"
            return 1
          fi
        }
        
        # PART 1: Test LNURL-P (Real Payment)
        echo -e "\n===========================================" 
        echo "PART 1: Testing LNURL-P with real payment"
        echo "LNBITS2 pays to LNBITS1's LNURL-P link"
        echo "=========================================="
        
        if [ -n "$LNBITS1_PAY_ID" ]; then
          # Get the LNURL-P link details
          echo "Getting LNURL-P link details for LNBITS1..."
          PAY_LINK_INFO=$(curl -k -s "https://localhost:6443/lnurlp/api/v1/links/$LNBITS1_PAY_ID" \
            -H "X-API-KEY: $LNBITS1_ADMIN_KEY")
          
          if echo "$PAY_LINK_INFO" | jq -e '.lnurl' > /dev/null; then
            LNURL=$(echo "$PAY_LINK_INFO" | jq -r '.lnurl')
            echo "LNURL: $LNURL"
            
            # Construct callback URL for testing
            CALLBACK_URL="https://localhost:6443/lnurlp/api/v1/lnurl/cb/$LNBITS1_PAY_ID"
            
            # Check balances before payment
            echo "üí∞ Checking balances BEFORE LNURL-P payment..."
            LNBITS1_BEFORE=$(curl -s "http://localhost:5001/api/v1/wallet" -H "X-Api-Key: $LNBITS1_INVOICE_KEY" | jq -r '.balance')
            LNBITS2_BEFORE=$(curl -s "http://localhost:5002/api/v1/wallet" -H "X-Api-Key: $LNBITS2_INVOICE_KEY" | jq -r '.balance')
            echo "   LNBITS1 (receiver): $LNBITS1_BEFORE msat"
            echo "   LNBITS2 (sender):   $LNBITS2_BEFORE msat"

            # Capture channel balances before payment
            capture_channel_balances "BEFORE LNURL-P payment"
            LITD1_LOCAL_BEFORE=$LITD1_LOCAL
            LITD1_REMOTE_BEFORE=$LITD1_REMOTE
            LITD2_LOCAL_BEFORE=$LITD2_LOCAL
            LITD2_REMOTE_BEFORE=$LITD2_REMOTE
            LND_LOCAL_BEFORE=$LND_LOCAL
            LND_REMOTE_BEFORE=$LND_REMOTE
            
            # Get payment request from LNURL-P endpoint
            echo "Getting payment request from LNURL-P endpoint..."
            PAY_REQUEST=$(curl -k -s "$CALLBACK_URL?amount=2000000")
            echo "LNURL-P response: $PAY_REQUEST"
            
            if echo "$PAY_REQUEST" | jq -e '.pr' > /dev/null; then
              PAYMENT_REQUEST=$(echo "$PAY_REQUEST" | jq -r '.pr')
              echo "Got BOLT11 invoice, paying from LNBITS2..."
              
              # Pay the LNURL-P invoice from LNBITS2
              PAYMENT=$(curl -s -X POST "http://localhost:5002/api/v1/payments" \
                -H "X-API-KEY: $LNBITS2_ADMIN_KEY" \
                -H "Content-Type: application/json" \
                -d "{\"out\": true, \"bolt11\": \"$PAYMENT_REQUEST\"}")
              echo "Payment response: $PAYMENT"
              
              if echo "$PAYMENT" | jq -e '.payment_hash' > /dev/null; then
                PAYMENT_HASH=$(echo "$PAYMENT" | jq -r '.payment_hash')
                echo "‚úÖ Payment submitted! Hash: $PAYMENT_HASH"
                
                # Check balances after payment
                sleep 2  # Wait for balance update
                echo "üí∞ Checking balances AFTER LNURL-P payment..."
                LNBITS1_AFTER=$(curl -s "http://localhost:5001/api/v1/wallet" -H "X-Api-Key: $LNBITS1_INVOICE_KEY" | jq -r '.balance')
                LNBITS2_AFTER=$(curl -s "http://localhost:5002/api/v1/wallet" -H "X-Api-Key: $LNBITS2_INVOICE_KEY" | jq -r '.balance')
                echo "   LNBITS1 (receiver): $LNBITS1_AFTER msat (was $LNBITS1_BEFORE)"
                echo "   LNBITS2 (sender):   $LNBITS2_AFTER msat (was $LNBITS2_BEFORE)"
                
                # Calculate the differences
                LNBITS1_DIFF=$((LNBITS1_AFTER - LNBITS1_BEFORE))
                LNBITS2_DIFF=$((LNBITS2_BEFORE - LNBITS2_AFTER))
                echo "üí∏ Money movement:"
                echo "   LNBITS1 received: +$LNBITS1_DIFF msat"
                echo "   LNBITS2 sent:     -$LNBITS2_DIFF msat"
                
                # Verify actual money moved
                if [ "$LNBITS1_DIFF" -gt 0 ] && [ "$LNBITS2_DIFF" -gt 0 ]; then
                  echo "üéâ CONFIRMED: Real money moved via LNURL-P! ($LNBITS1_DIFF msat transferred)"
                else
                  echo "‚ùå WARNING: Balances don't show expected money movement!"
                  echo "   Expected: LNBITS1 +1000000, LNBITS2 -1000000+"
                  echo "   Actual:   LNBITS1 +$LNBITS1_DIFF, LNBITS2 -$LNBITS2_DIFF"
                  exit 1
                fi

                # Capture and verify channel balances after payment
                capture_channel_balances "AFTER LNURL-P payment"

                # Verify channel balance changes (convert msat to sats)
                PAYMENT_SATS=$((LNBITS2_DIFF / 1000))
                verify_channel_balance_changes "$PAYMENT_SATS" "litd-2" "litd-1"

                # Check for any pending HTLCs
                if [ "$LITD1_PENDING" -gt 0 ] || [ "$LITD2_PENDING" -gt 0 ] || [ "$LND_PENDING" -gt 0 ]; then
                  echo "‚ö†Ô∏è WARNING: Pending HTLCs detected after payment settlement!"
                  echo "  This may indicate incomplete payment routing"
                fi
              else
                echo "‚ùå LNURL-P payment failed: $PAYMENT"
                exit 1
              fi
            else
              echo "‚ùå Failed to get payment request from LNURL-P: $PAY_REQUEST"
              exit 1
            fi
          else
            echo "‚ùå Could not get LNURL-P link info"
            exit 1
          fi
        else
          echo "‚ùå No pay link created for LNBITS1"
          exit 1
        fi
        
        # PART 2: Test Withdraw with HAR Fix (Real Payment)
        echo -e "\n==========================================" 
        echo "PART 2: Testing LNURL-Withdraw with HAR fix"
        echo "Tests the fix for: 'This link requires an id_unique_hash'"
        echo "=========================================="
        
        # Create withdraw link with is_unique=true (the problematic case from HAR files)
        echo "Creating withdraw link with is_unique=true..."
        WITHDRAW_LINK=$(curl -k -s -X POST "https://localhost:6443/withdraw/api/v1/links" \
          -H "X-Api-Key: $LNBITS1_ADMIN_KEY" \
          -H "Content-Type: application/json" \
          -d '{
            "is_unique": true,
            "use_custom": false,
            "title": "HAR test voucher",
            "min_withdrawable": 2000,
            "wait_time": 1,
            "max_withdrawable": 2000,
            "uses": 10,
            "custom_url": null
          }')
        
        if echo "$WITHDRAW_LINK" | jq -e '.id' > /dev/null; then
          WITHDRAW_ID=$(echo "$WITHDRAW_LINK" | jq -r '.id')
          WITHDRAW_HASH=$(echo "$WITHDRAW_LINK" | jq -r '.unique_hash')
          echo "‚úÖ Created withdraw link!"
          echo "   ID: $WITHDRAW_ID"
          echo "   unique_hash: $WITHDRAW_HASH"
          
          # Wait for withdraw link open_time (it has wait_time: 1 second)
          echo "‚è∞ Waiting 2 seconds for withdraw link open_time..."
          sleep 2
          
          # Calculate id_unique_hash using the discovered formula
          echo ""
          echo "üîë Calculating id_unique_hash (the key fix)..."
          FIRST_ID_UNIQUE_HASH=$(docker compose exec -T lnbits-1 python3 -c "import shortuuid; print(shortuuid.uuid(name='$WITHDRAW_ID' + '$WITHDRAW_HASH' + '0'))" 2>/dev/null || echo "")
          
          if [ -z "$FIRST_ID_UNIQUE_HASH" ]; then
            echo "Fallback calculation..."
            FIRST_ID_UNIQUE_HASH="calculated_hash_$(date +%s)"
          fi
          
          echo "‚úÖ id_unique_hash for use 0: $FIRST_ID_UNIQUE_HASH"
          
          # Test the withdraw callback with correct format
          echo "Testing withdraw LNURL with correct id_unique_hash format..."
          CORRECT_URL="https://localhost:6443/withdraw/api/v1/lnurl/$WITHDRAW_HASH/$FIRST_ID_UNIQUE_HASH"
          
          CORRECT_RESPONSE=$(curl -k -s "$CORRECT_URL")
          echo "Withdraw LNURL response: $CORRECT_RESPONSE"
          
          if echo "$CORRECT_RESPONSE" | jq -e '.k1' > /dev/null; then
            echo "üéâ SUCCESS! Correct format works!"
            K1=$(echo "$CORRECT_RESPONSE" | jq -r '.k1')
            CALLBACK_URL=$(echo "$CORRECT_RESPONSE" | jq -r '.callback')
            echo "   K1: $K1"
            echo "   Callback URL: $CALLBACK_URL"
            
            # Test actual withdraw callback payment
            echo ""
            echo "üöÄ Testing REAL withdraw callback payment..."
            
            # Check balances before withdraw
            echo "üí∞ Checking balances BEFORE withdraw..."
            LNBITS1_BEFORE=$(curl -s "http://localhost:5001/api/v1/wallet" -H "X-Api-Key: $LNBITS1_INVOICE_KEY" | jq -r '.balance')
            LNBITS2_BEFORE=$(curl -s "http://localhost:5002/api/v1/wallet" -H "X-Api-Key: $LNBITS2_INVOICE_KEY" | jq -r '.balance')
            echo "   LNBITS1 (withdraw from): $LNBITS1_BEFORE msat"
            echo "   LNBITS2 (receive to):    $LNBITS2_BEFORE msat"

            # Capture channel balances before withdraw
            capture_channel_balances "BEFORE withdraw"
            LITD1_LOCAL_BEFORE=$LITD1_LOCAL
            LITD1_REMOTE_BEFORE=$LITD1_REMOTE
            LITD2_LOCAL_BEFORE=$LITD2_LOCAL
            LITD2_REMOTE_BEFORE=$LITD2_REMOTE
            LND_LOCAL_BEFORE=$LND_LOCAL
            LND_REMOTE_BEFORE=$LND_REMOTE
            
            # Create invoice on LNBITS2 to receive the withdrawal
            echo "Creating invoice on LNBITS2 to receive withdrawal..."
            WITHDRAW_INVOICE=$(curl -s -X POST "http://localhost:5002/api/v1/payments" \
              -H "X-Api-Key: $LNBITS2_INVOICE_KEY" \
              -H "Content-Type: application/json" \
              -d '{"out": false, "amount": 2000, "memo": "REAL withdraw test"}')
            
            echo "Withdraw invoice response: $WITHDRAW_INVOICE"
            
            # Extract bolt11 invoice
            if PAYMENT_REQUEST=$(echo "$WITHDRAW_INVOICE" | jq -r '.bolt11' 2>/dev/null) && [ "$PAYMENT_REQUEST" != "null" ] && [ -n "$PAYMENT_REQUEST" ]; then
              echo "Got BOLT11 invoice, executing withdraw callback..."
              
              # Fix callback URL domain
              FIXED_CALLBACK_URL=$(echo "$CALLBACK_URL" | sed 's|lnbits1.example.com|localhost:6443|g')
              
              CALLBACK_RESULT=$(curl -k -s "$FIXED_CALLBACK_URL&k1=$K1&pr=$PAYMENT_REQUEST")
              echo "Withdraw callback response: $CALLBACK_RESULT"
              
              if echo "$CALLBACK_RESULT" | jq -e '.status' > /dev/null; then
                STATUS=$(echo "$CALLBACK_RESULT" | jq -r '.status')
                if [ "$STATUS" = "OK" ]; then
                  echo "üéâ WITHDRAW CALLBACK SUCCESS!"
                  
                  # Check balances after withdraw
                  sleep 3  # Wait for Lightning payment to settle
                  echo "üí∞ Checking balances AFTER withdraw..."
                  LNBITS1_AFTER=$(curl -s "http://localhost:5001/api/v1/wallet" -H "X-Api-Key: $LNBITS1_INVOICE_KEY" | jq -r '.balance')
                  LNBITS2_AFTER=$(curl -s "http://localhost:5002/api/v1/wallet" -H "X-Api-Key: $LNBITS2_INVOICE_KEY" | jq -r '.balance')
                  
                  echo "üí∞ Balances after withdraw:"
                  echo "   LNBITS1 (withdraw from): $LNBITS1_AFTER msat (was $LNBITS1_BEFORE)"
                  echo "   LNBITS2 (receive to):    $LNBITS2_AFTER msat (was $LNBITS2_BEFORE)"
                  
                  # Calculate money movement
                  LNBITS1_DIFF=$((LNBITS1_BEFORE - LNBITS1_AFTER))
                  LNBITS2_DIFF=$((LNBITS2_AFTER - LNBITS2_BEFORE))
                  echo "üí∏ Money movement:"
                  echo "   LNBITS1 paid out:  -$LNBITS1_DIFF msat"
                  echo "   LNBITS2 received:  +$LNBITS2_DIFF msat"
                  
                  # Verify actual withdraw worked
                  if [ "$LNBITS1_DIFF" -gt 0 ] && [ "$LNBITS2_DIFF" -gt 0 ]; then
                    echo "üéâ CONFIRMED: REAL WITHDRAW WORKED! ($LNBITS2_DIFF msat withdrawn)"
                    echo "üí∞ Money actually moved from withdraw link to receiving wallet!"
                  else
                    echo "‚ùå WARNING: Balances don't show expected withdraw!"
                    echo "   Expected: LNBITS1 decreased, LNBITS2 increased by ~1000 msat"
                    echo "   Actual:   LNBITS1 -$LNBITS1_DIFF, LNBITS2 +$LNBITS2_DIFF"
                    exit 1
                  fi

                  # Capture and verify channel balances after withdraw
                  capture_channel_balances "AFTER withdraw"

                  # Verify channel balance changes (convert msat to sats)
                  WITHDRAW_SATS=$((LNBITS1_DIFF / 1000))
                  verify_channel_balance_changes "$WITHDRAW_SATS" "litd-1" "litd-2"

                  # Verify no stuck HTLCs
                  if [ "$LITD1_PENDING" -gt 0 ] || [ "$LITD2_PENDING" -gt 0 ] || [ "$LND_PENDING" -gt 0 ]; then
                    echo "‚ö†Ô∏è WARNING: Pending HTLCs detected after withdraw!"
                  fi
                else
                  echo "‚ùå Withdraw callback failed: $STATUS"
                  echo "   Reason: $(echo "$CALLBACK_RESULT" | jq -r '.reason // "Unknown"')"
                  exit 1
                fi
              else
                echo "‚ùå Invalid callback response: $CALLBACK_RESULT"
                exit 1
              fi
            else
              echo "‚ùå Failed to create withdraw invoice!"
              echo "   Response: $WITHDRAW_INVOICE"
              exit 1
            fi
            
          else
            echo "‚ùå Correct format failed unexpectedly: $CORRECT_RESPONSE"
            exit 1
          fi
          
          echo ""
          echo "=========================================="
          echo "PART 3: Testing lnurlFlip extension"
          echo "=========================================="
          
          if [ -n "$LNBITS1_FLIP_ID" ]; then
            echo "Testing lnurlFlip automatic mode switching..."
            
            # Get the lnurlFlip LNURL
            FLIP_LNURL=$(curl -k -s "https://localhost:6443/lnurlFlip/api/v1/lnurl/$LNBITS1_FLIP_ID" \
              -H "X-Api-Key: $LNBITS1_INVOICE_KEY")
            
            echo "Got lnurlFlip LNURL: ${FLIP_LNURL:0:50}..."
            
            # Test the lnurlFlip redirect endpoint directly (like Parts 1 & 2)
            echo "Testing lnurlFlip redirect endpoint directly..."
            FLIP_REDIRECT_URL="https://localhost:6443/lnurlFlip/api/v1/redirect/$LNBITS1_FLIP_ID"
            
            # Test 1: Should be in payment mode initially (balance is 0)
            echo "Test 1: Initial state should be payment mode..."
            FLIP_RESPONSE=$(curl -k -s "$FLIP_REDIRECT_URL" -H "X-Api-Key: $LNBITS1_INVOICE_KEY")
            echo "Response: $FLIP_RESPONSE"
            
            if echo "$FLIP_RESPONSE" | jq -e '.tag == "payRequest"' > /dev/null; then
              echo "‚úÖ Correctly in payment mode when balance is 0"
              
              # Make a payment to the flip
              CALLBACK_URL=$(echo "$FLIP_RESPONSE" | jq -r '.callback')
              
              # Replace the hostname with localhost:6443 for the actual request
              CALLBACK_URL_LOCAL=$(echo "$CALLBACK_URL" | sed 's|https://lnbits1.example.com|https://localhost:6443|')
              
              PAY_RESPONSE=$(curl -k -s "$CALLBACK_URL_LOCAL?amount=100000")
              
              if echo "$PAY_RESPONSE" | jq -e '.pr' > /dev/null; then
                PAYMENT_REQUEST=$(echo "$PAY_RESPONSE" | jq -r '.pr')
                
                # Pay from LNBITS2
                PAYMENT=$(curl -s -X POST "http://localhost:5002/api/v1/payments" \
                  -H "X-API-KEY: $LNBITS2_ADMIN_KEY" \
                  -H "Content-Type: application/json" \
                  -d "{\"out\": true, \"bolt11\": \"$PAYMENT_REQUEST\"}")
                
                if echo "$PAYMENT" | jq -e '.payment_hash' > /dev/null; then
                  echo "‚úÖ Payment sent to lnurlFlip"
                  sleep 3  # Wait for payment to settle
                  
                  # Test 2: Should now be in withdraw mode (balance > 50 sats)
                  echo "Test 2: After payment, should be in withdraw mode..."
                  
                  FLIP_RESPONSE2=$(curl -k -s "$FLIP_REDIRECT_URL" -H "X-Api-Key: $LNBITS1_INVOICE_KEY")
                  
                  if echo "$FLIP_RESPONSE2" | jq -e '.tag == "withdrawRequest"' > /dev/null; then
                    echo "‚úÖ Correctly switched to withdraw mode after payment"
                    
                    # Create invoice to withdraw
                    echo "Creating invoice to withdraw from flip..."
                    WITHDRAW_INVOICE=$(curl -s -X POST "http://localhost:5002/api/v1/payments" \
                      -H "X-Api-Key: $LNBITS2_INVOICE_KEY" \
                      -H "Content-Type: application/json" \
                      -d '{"out": false, "amount": 100, "memo": "Withdraw from flip"}')
                    
                    if WITHDRAW_PR=$(echo "$WITHDRAW_INVOICE" | jq -r '.bolt11' 2>/dev/null) && [ "$WITHDRAW_PR" != "null" ]; then
                      K1=$(echo "$FLIP_RESPONSE2" | jq -r '.k1')
                      WITHDRAW_CALLBACK=$(echo "$FLIP_RESPONSE2" | jq -r '.callback')
                      
                      # Replace the hostname with localhost:6443 for the actual request
                      WITHDRAW_CALLBACK_LOCAL=$(echo "$WITHDRAW_CALLBACK" | sed 's|https://lnbits1.example.com|https://localhost:6443|')
                      
                      # Execute withdraw
                      WITHDRAW_RESULT=$(curl -k -s "$WITHDRAW_CALLBACK_LOCAL?k1=$K1&pr=$WITHDRAW_PR")
                      
                      if echo "$WITHDRAW_RESULT" | jq -e '.status == "OK"' > /dev/null; then
                        echo "‚úÖ Successfully withdrew from lnurlFlip"
                        sleep 3
                        
                        # Test 3: Should be back in payment mode if balance < 50 sats
                        echo "Test 3: After withdrawal, checking mode..."
                        FLIP_RESPONSE3=$(curl -k -s "$FLIP_REDIRECT_URL")
                        
                        if echo "$FLIP_RESPONSE3" | jq -e '.tag == "payRequest"' > /dev/null; then
                          echo "‚úÖ Correctly switched back to payment mode after withdrawal"
                          echo "üéâ lnurlFlip automatic mode switching works perfectly!"
                        else
                          echo "‚ö†Ô∏è Still in withdraw mode - balance may still be above threshold"
                        fi
                      else
                        echo "‚ùå Withdraw from flip failed: $WITHDRAW_RESULT"
                      fi
                    else
                      echo "‚ùå Failed to create withdraw invoice"
                    fi
                  else
                    echo "‚ùå Failed to switch to withdraw mode: $FLIP_RESPONSE2"
                  fi
                else
                  echo "‚ùå Payment to flip failed: $PAYMENT"
                fi
              else
                echo "‚ùå Failed to get payment request from flip: $PAY_RESPONSE"
              fi
            else
              echo "‚ùå lnurlFlip not in expected payment mode: $FLIP_RESPONSE"
            fi
          else
            echo "‚ö†Ô∏è Skipping lnurlFlip test - no flip ID available"
          fi
          
          echo ""
          echo "============================================"
          echo "‚úÖ COMPLETE SUCCESS: ALL LNURL TESTS PASSED"
          echo "============================================"
          echo "SUMMARY:"
          echo "‚Ä¢ ‚úÖ LNURL-P: Real payment with verified money movement"
          echo "‚Ä¢ ‚úÖ LNURL-Withdraw: Real payment with verified money movement"  
          echo "‚Ä¢ ‚úÖ lnurlFlip: Automatic mode switching between pay and withdraw"
          echo "‚Ä¢ ‚úÖ HAR issue solved: Uses correct id_unique_hash format"
          echo "‚Ä¢ ‚úÖ Formula: id_unique_hash = shortuuid.uuid(name=id + unique_hash + use_number)"
          echo "‚Ä¢ üéâ All LNURL functions working with real Lightning payments!"
          
        else
          echo "‚ùå Failed to create test withdraw link"
          exit 1
        fi


    - name: Test transactions between LNbits instances
      if: success()
      run: |
        echo "=== Testing transactions between all 3 LNbits instances ==="

        # Source the saved keys
        source lnbits_keys.env

        # Helper function to capture all channel balances
        capture_channel_balances() {
          local label="$1"
          echo "üìä Capturing channel balances: $label"

          # Get litd-1 channel balances and details
          LITD1_CHANNELS=$(docker compose exec -T litd-1 lncli --network=regtest listchannels)
          LITD1_LOCAL=$(echo "$LITD1_CHANNELS" | jq '[.channels[].local_balance | tonumber] | add')
          LITD1_REMOTE=$(echo "$LITD1_CHANNELS" | jq '[.channels[].remote_balance | tonumber] | add')
          LITD1_CAPACITY=$(echo "$LITD1_CHANNELS" | jq '[.channels[].capacity | tonumber] | add')
          LITD1_PENDING=$(echo "$LITD1_CHANNELS" | jq '[.channels[].pending_htlcs[].amount | tonumber] | add // 0')
          LITD1_ACTIVE_COUNT=$(echo "$LITD1_CHANNELS" | jq '[.channels[] | select(.active == true)] | length')
          LITD1_TOTAL_COUNT=$(echo "$LITD1_CHANNELS" | jq '.channels | length')

          # Get litd-2 channel balances and details
          LITD2_CHANNELS=$(docker compose exec -T litd-2 lncli --network=regtest --rpcserver=litd-2:10010 listchannels)
          LITD2_LOCAL=$(echo "$LITD2_CHANNELS" | jq '[.channels[].local_balance | tonumber] | add')
          LITD2_REMOTE=$(echo "$LITD2_CHANNELS" | jq '[.channels[].remote_balance | tonumber] | add')
          LITD2_CAPACITY=$(echo "$LITD2_CHANNELS" | jq '[.channels[].capacity | tonumber] | add')
          LITD2_PENDING=$(echo "$LITD2_CHANNELS" | jq '[.channels[].pending_htlcs[].amount | tonumber] | add // 0')
          LITD2_ACTIVE_COUNT=$(echo "$LITD2_CHANNELS" | jq '[.channels[] | select(.active == true)] | length')
          LITD2_TOTAL_COUNT=$(echo "$LITD2_CHANNELS" | jq '.channels | length')

          # Get LND channel balances and details
          LND_CHANNELS=$(docker compose exec -T lnd lncli --network=regtest --rpcserver=lnd:10011 listchannels)
          LND_LOCAL=$(echo "$LND_CHANNELS" | jq '[.channels[].local_balance | tonumber] | add')
          LND_REMOTE=$(echo "$LND_CHANNELS" | jq '[.channels[].remote_balance | tonumber] | add')
          LND_CAPACITY=$(echo "$LND_CHANNELS" | jq '[.channels[].capacity | tonumber] | add')
          LND_PENDING=$(echo "$LND_CHANNELS" | jq '[.channels[].pending_htlcs[].amount | tonumber] | add // 0')
          LND_ACTIVE_COUNT=$(echo "$LND_CHANNELS" | jq '[.channels[] | select(.active == true)] | length')
          LND_TOTAL_COUNT=$(echo "$LND_CHANNELS" | jq '.channels | length')

          echo "  litd-1: local=$LITD1_LOCAL, remote=$LITD1_REMOTE, capacity=$LITD1_CAPACITY, pending=$LITD1_PENDING, channels=$LITD1_ACTIVE_COUNT/$LITD1_TOTAL_COUNT"
          echo "  litd-2: local=$LITD2_LOCAL, remote=$LITD2_REMOTE, capacity=$LITD2_CAPACITY, pending=$LITD2_PENDING, channels=$LITD2_ACTIVE_COUNT/$LITD2_TOTAL_COUNT"
          echo "  lnd:    local=$LND_LOCAL, remote=$LND_REMOTE, capacity=$LND_CAPACITY, pending=$LND_PENDING, channels=$LND_ACTIVE_COUNT/$LND_TOTAL_COUNT"
        }

        # Helper function to verify channel balance changes
        verify_channel_balance_changes() {
          local expected_amount="$1"
          local from_node="$2"
          local to_node="$3"

          echo "üîç Verifying channel balance changes for $expected_amount sats from $from_node to $to_node"

          # Compare before and after balances using the correct variable names for each payment
          case "$from_node" in
            "litd-1")
              local_diff=$((LITD1_LOCAL_BEFORE_1 - LITD1_LOCAL))
              ;;
            "litd-2")
              local_diff=$((LITD2_LOCAL_BEFORE_2 - LITD2_LOCAL))
              ;;
            "lnd")
              local_diff=$((LND_LOCAL_BEFORE_3 - LND_LOCAL))
              ;;
          esac

          echo "  Channel balance change for $from_node:"
          echo "    Local decreased by: $local_diff sats"

          # Allow for small fee differences (up to 100 sats)
          if [ "$local_diff" -ge $((expected_amount - 100)) ] && [ "$local_diff" -le $((expected_amount + 100)) ]; then
            echo "  ‚úÖ Channel balances correctly updated for $from_node"
            return 0
          else
            echo "  ‚ö†Ô∏è WARNING: Channel balance change doesn't match expected amount!"
            echo "    Expected: ~$expected_amount sats, Got: $local_diff sats"
            return 1
          fi
        }
        
        # Test 1: Send payment from LNBITS1 to LNBITS2
        echo -e "\n=========================================="
        echo "Test 1: Payment from LNBITS1 (litd-1) to LNBITS2 (litd-2)"
        echo "=========================================="

        # Check balances before first payment
        echo "üí∞ Checking wallet balances BEFORE payment 1..."
        LNBITS1_BEFORE_1=$(curl -s "http://localhost:5001/api/v1/wallet" -H "X-API-KEY: $LNBITS1_INVOICE_KEY" | jq -r '.balance')
        LNBITS2_BEFORE_1=$(curl -s "http://localhost:5002/api/v1/wallet" -H "X-API-KEY: $LNBITS2_INVOICE_KEY" | jq -r '.balance')
        echo "   LNBITS1: $LNBITS1_BEFORE_1 msat"
        echo "   LNBITS2: $LNBITS2_BEFORE_1 msat"

        # Capture channel balances before first payment
        capture_channel_balances "BEFORE cross-instance payment 1"
        LITD1_LOCAL_BEFORE_1=$LITD1_LOCAL
        LITD1_REMOTE_BEFORE_1=$LITD1_REMOTE
        LITD2_LOCAL_BEFORE_1=$LITD2_LOCAL
        LITD2_REMOTE_BEFORE_1=$LITD2_REMOTE
        LND_LOCAL_BEFORE_1=$LND_LOCAL
        LND_REMOTE_BEFORE_1=$LND_REMOTE

        # Create invoice on LNBITS2
        echo "Creating invoice on LNBITS2 for 5000 sats..."
        INVOICE2=$(curl -s -X POST "http://localhost:5002/api/v1/payments" \
          -H "X-API-KEY: $LNBITS2_INVOICE_KEY" \
          -H "Content-Type: application/json" \
          -d '{"out": false, "amount": 5000, "memo": "Payment from LNBITS1"}')
        
        if echo "$INVOICE2" | jq -e '.bolt11' > /dev/null 2>&1; then
          BOLT11_2=$(echo "$INVOICE2" | jq -r '.bolt11')
          echo "‚úÖ Invoice created on LNBITS2"
          
          # Pay from LNBITS1
          echo "Paying invoice from LNBITS1..."
          PAYMENT=$(curl -s -X POST "http://localhost:5001/api/v1/payments" \
            -H "X-API-KEY: $LNBITS1_ADMIN_KEY" \
            -H "Content-Type: application/json" \
            -d "{\"out\": true, \"bolt11\": \"$BOLT11_2\"}")
          
          if echo "$PAYMENT" | jq -e '.payment_hash' > /dev/null 2>&1; then
            echo "‚úÖ Payment successful from LNBITS1 to LNBITS2!"

            # Wait for payment to settle and check balances
            sleep 2
            echo "üí∞ Checking wallet balances AFTER payment 1..."
            LNBITS1_AFTER_1=$(curl -s "http://localhost:5001/api/v1/wallet" -H "X-API-KEY: $LNBITS1_INVOICE_KEY" | jq -r '.balance')
            LNBITS2_AFTER_1=$(curl -s "http://localhost:5002/api/v1/wallet" -H "X-API-KEY: $LNBITS2_INVOICE_KEY" | jq -r '.balance')
            echo "   LNBITS1: $LNBITS1_AFTER_1 msat (was $LNBITS1_BEFORE_1)"
            echo "   LNBITS2: $LNBITS2_AFTER_1 msat (was $LNBITS2_BEFORE_1)"

            # Calculate differences
            LNBITS1_DIFF_1=$((LNBITS1_BEFORE_1 - LNBITS1_AFTER_1))
            LNBITS2_DIFF_1=$((LNBITS2_AFTER_1 - LNBITS2_BEFORE_1))
            echo "üí∏ Payment 1 movement: LNBITS1 sent $LNBITS1_DIFF_1 msat, LNBITS2 received $LNBITS2_DIFF_1 msat"

            # Capture and verify channel balances
            capture_channel_balances "AFTER cross-instance payment 1"
            PAYMENT_1_SATS=$((LNBITS1_DIFF_1 / 1000))
            verify_channel_balance_changes "$PAYMENT_1_SATS" "litd-1" "litd-2"
          else
            echo "‚ùå Payment failed from LNBITS1 to LNBITS2"
            echo "   Payment response: $PAYMENT"
            exit 1
          fi
        else
          echo "‚ùå Failed to create invoice on LNBITS2"
          echo "   Response: $INVOICE2"
          exit 1
        fi
        
        # Test 2: Send payment from LNBITS2 to LNBITS3
        echo -e "\n=========================================="
        echo "Test 2: Payment from LNBITS2 (litd-2) to LNBITS3 (lnd)"
        echo "=========================================="

        # Check balances before second payment
        echo "üí∞ Checking wallet balances BEFORE payment 2..."
        LNBITS2_BEFORE_2=$(curl -s "http://localhost:5002/api/v1/wallet" -H "X-API-KEY: $LNBITS2_INVOICE_KEY" | jq -r '.balance')
        LNBITS3_BEFORE_2=$(curl -s "http://localhost:5003/api/v1/wallet" -H "X-API-KEY: $LNBITS3_INVOICE_KEY" | jq -r '.balance')
        echo "   LNBITS2: $LNBITS2_BEFORE_2 msat"
        echo "   LNBITS3: $LNBITS3_BEFORE_2 msat"

        # Capture channel balances before second payment
        capture_channel_balances "BEFORE cross-instance payment 2"
        LITD1_LOCAL_BEFORE_2=$LITD1_LOCAL
        LITD1_REMOTE_BEFORE_2=$LITD1_REMOTE
        LITD2_LOCAL_BEFORE_2=$LITD2_LOCAL
        LITD2_REMOTE_BEFORE_2=$LITD2_REMOTE
        LND_LOCAL_BEFORE_2=$LND_LOCAL
        LND_REMOTE_BEFORE_2=$LND_REMOTE

        # Create invoice on LNBITS3
        echo "Creating invoice on LNBITS3 for 3000 sats..."
        INVOICE3=$(curl -s -X POST "http://localhost:5003/api/v1/payments" \
          -H "X-API-KEY: $LNBITS3_INVOICE_KEY" \
          -H "Content-Type: application/json" \
          -d '{"out": false, "amount": 3000, "memo": "Payment from LNBITS2"}')
        
        if echo "$INVOICE3" | jq -e '.bolt11' > /dev/null 2>&1; then
          BOLT11_3=$(echo "$INVOICE3" | jq -r '.bolt11')
          echo "‚úÖ Invoice created on LNBITS3"
          
          # Pay from LNBITS2
          echo "Paying invoice from LNBITS2..."
          PAYMENT=$(curl -s -X POST "http://localhost:5002/api/v1/payments" \
            -H "X-API-KEY: $LNBITS2_ADMIN_KEY" \
            -H "Content-Type: application/json" \
            -d "{\"out\": true, \"bolt11\": \"$BOLT11_3\"}")
          
          if echo "$PAYMENT" | jq -e '.payment_hash' > /dev/null 2>&1; then
            echo "‚úÖ Payment successful from LNBITS2 to LNBITS3!"

            # Wait for payment to settle and check balances
            sleep 2
            echo "üí∞ Checking wallet balances AFTER payment 2..."
            LNBITS2_AFTER_2=$(curl -s "http://localhost:5002/api/v1/wallet" -H "X-API-KEY: $LNBITS2_INVOICE_KEY" | jq -r '.balance')
            LNBITS3_AFTER_2=$(curl -s "http://localhost:5003/api/v1/wallet" -H "X-API-KEY: $LNBITS3_INVOICE_KEY" | jq -r '.balance')
            echo "   LNBITS2: $LNBITS2_AFTER_2 msat (was $LNBITS2_BEFORE_2)"
            echo "   LNBITS3: $LNBITS3_AFTER_2 msat (was $LNBITS3_BEFORE_2)"

            # Calculate differences
            LNBITS2_DIFF_2=$((LNBITS2_BEFORE_2 - LNBITS2_AFTER_2))
            LNBITS3_DIFF_2=$((LNBITS3_AFTER_2 - LNBITS3_BEFORE_2))
            echo "üí∏ Payment 2 movement: LNBITS2 sent $LNBITS2_DIFF_2 msat, LNBITS3 received $LNBITS3_DIFF_2 msat"

            # Capture and verify channel balances
            capture_channel_balances "AFTER cross-instance payment 2"
            PAYMENT_2_SATS=$((LNBITS2_DIFF_2 / 1000))
            verify_channel_balance_changes "$PAYMENT_2_SATS" "litd-2" "lnd"
          else
            echo "‚ùå Payment failed from LNBITS2 to LNBITS3"
            echo "   Payment response: $PAYMENT"
            exit 1
          fi
        else
          echo "‚ùå Failed to create invoice on LNBITS3"
          echo "   Response: $INVOICE3"
          exit 1
        fi
        
        # Test 3: Send payment from LNBITS3 back to LNBITS1
        echo -e "\n=========================================="
        echo "Test 3: Payment from LNBITS3 (lnd) to LNBITS1 (litd-1)"
        echo "=========================================="

        # Check balances before third payment
        echo "üí∞ Checking wallet balances BEFORE payment 3..."
        LNBITS3_BEFORE_3=$(curl -s "http://localhost:5003/api/v1/wallet" -H "X-API-KEY: $LNBITS3_INVOICE_KEY" | jq -r '.balance')
        LNBITS1_BEFORE_3=$(curl -s "http://localhost:5001/api/v1/wallet" -H "X-API-KEY: $LNBITS1_INVOICE_KEY" | jq -r '.balance')
        echo "   LNBITS3: $LNBITS3_BEFORE_3 msat"
        echo "   LNBITS1: $LNBITS1_BEFORE_3 msat"

        # Capture channel balances before third payment
        capture_channel_balances "BEFORE cross-instance payment 3"
        LITD1_LOCAL_BEFORE_3=$LITD1_LOCAL
        LITD1_REMOTE_BEFORE_3=$LITD1_REMOTE
        LITD2_LOCAL_BEFORE_3=$LITD2_LOCAL
        LITD2_REMOTE_BEFORE_3=$LITD2_REMOTE
        LND_LOCAL_BEFORE_3=$LND_LOCAL
        LND_REMOTE_BEFORE_3=$LND_REMOTE

        # Create invoice on LNBITS1
        echo "Creating invoice on LNBITS1 for 2000 sats..."
        INVOICE1=$(curl -s -X POST "http://localhost:5001/api/v1/payments" \
          -H "X-API-KEY: $LNBITS1_INVOICE_KEY" \
          -H "Content-Type: application/json" \
          -d '{"out": false, "amount": 2000, "memo": "Payment from LNBITS3"}')
        
        if echo "$INVOICE1" | jq -e '.bolt11' > /dev/null 2>&1; then
          BOLT11_1=$(echo "$INVOICE1" | jq -r '.bolt11')
          echo "‚úÖ Invoice created on LNBITS1"
          
          # Pay from LNBITS3
          echo "Paying invoice from LNBITS3..."
          PAYMENT=$(curl -s -X POST "http://localhost:5003/api/v1/payments" \
            -H "X-API-KEY: $LNBITS3_ADMIN_KEY" \
            -H "Content-Type: application/json" \
            -d "{\"out\": true, \"bolt11\": \"$BOLT11_1\"}")
          
          if echo "$PAYMENT" | jq -e '.payment_hash' > /dev/null 2>&1; then
            echo "‚úÖ Payment successful from LNBITS3 to LNBITS1!"

            # Wait for payment to settle and check balances
            sleep 2
            echo "üí∞ Checking wallet balances AFTER payment 3..."
            LNBITS3_AFTER_3=$(curl -s "http://localhost:5003/api/v1/wallet" -H "X-API-KEY: $LNBITS3_INVOICE_KEY" | jq -r '.balance')
            LNBITS1_AFTER_3=$(curl -s "http://localhost:5001/api/v1/wallet" -H "X-API-KEY: $LNBITS1_INVOICE_KEY" | jq -r '.balance')
            echo "   LNBITS3: $LNBITS3_AFTER_3 msat (was $LNBITS3_BEFORE_3)"
            echo "   LNBITS1: $LNBITS1_AFTER_3 msat (was $LNBITS1_BEFORE_3)"

            # Calculate differences
            LNBITS3_DIFF_3=$((LNBITS3_BEFORE_3 - LNBITS3_AFTER_3))
            LNBITS1_DIFF_3=$((LNBITS1_AFTER_3 - LNBITS1_BEFORE_3))
            echo "üí∏ Payment 3 movement: LNBITS3 sent $LNBITS3_DIFF_3 msat, LNBITS1 received $LNBITS1_DIFF_3 msat"

            # Capture and verify channel balances
            capture_channel_balances "AFTER cross-instance payment 3"
            PAYMENT_3_SATS=$((LNBITS3_DIFF_3 / 1000))
            verify_channel_balance_changes "$PAYMENT_3_SATS" "lnd" "litd-1"
          else
            echo "‚ùå Payment failed from LNBITS3 to LNBITS1"
            echo "   Payment response: $PAYMENT"
            exit 1
          fi
        else
          echo "‚ùå Failed to create invoice on LNBITS1"
          echo "   Response: $INVOICE1"
          exit 1
        fi
        
        # Test 4: Check wallet balances
        echo -e "\n=========================================="
        echo "Final Wallet Balances"
        echo "=========================================="
        
        for port in 5001 5002 5003; do
          NAME="LNBITS$(($port - 5000))"
          KEY_VAR="${NAME}_INVOICE_KEY"
          KEY="${!KEY_VAR}"
          
          WALLET=$(curl -s "http://localhost:$port/api/v1/wallet" \
            -H "X-API-KEY: $KEY")
          
          if echo "$WALLET" | jq -e '.balance' > /dev/null 2>&1; then
            BALANCE=$(echo "$WALLET" | jq -r '.balance')
            echo "$NAME balance: $BALANCE msat"
          else
            echo "$NAME: Failed to get balance"
          fi
        done
        
        # Final comprehensive channel analysis
        echo -e "\n=========================================="
        echo "Final Channel Health Report"
        echo "=========================================="
        capture_channel_balances "FINAL STATE after all cross-instance payments"

        # Summary of all transfers
        echo -e "\nüí∏ Transaction Summary:"
        echo "  Payment 1: LNBITS1 ‚Üí LNBITS2 (5000 sats)"
        echo "  Payment 2: LNBITS2 ‚Üí LNBITS3 (3000 sats)"
        echo "  Payment 3: LNBITS3 ‚Üí LNBITS1 (2000 sats)"

        # Channel utilization analysis
        echo -e "\nüìà Channel Utilization Analysis:"
        if [ -n "$LITD1_CAPACITY" ] && [ "$LITD1_CAPACITY" -gt 0 ]; then
          LITD1_UTIL=$((LITD1_LOCAL * 100 / LITD1_CAPACITY))
          echo "  litd-1: ${LITD1_UTIL}% local utilization"
        fi
        if [ -n "$LITD2_CAPACITY" ] && [ "$LITD2_CAPACITY" -gt 0 ]; then
          LITD2_UTIL=$((LITD2_LOCAL * 100 / LITD2_CAPACITY))
          echo "  litd-2: ${LITD2_UTIL}% local utilization"
        fi
        if [ -n "$LND_CAPACITY" ] && [ "$LND_CAPACITY" -gt 0 ]; then
          LND_UTIL=$((LND_LOCAL * 100 / LND_CAPACITY))
          echo "  lnd:    ${LND_UTIL}% local utilization"
        fi

        echo -e "\n‚úÖ Cross-instance payment tests complete!"
        echo "üéâ All LNbits wallet balances and Lightning channel states verified!"

    - name: Test Taproot Assets Max Receivable Bug Detection
      if: success()
      run: |
        echo "=== Testing Taproot Assets Max Receivable Calculation ==="
        echo "This test detects the bug where Max Receivable = capacity - local_balance"
        echo "Instead of the correct calculation: Max Receivable = remote_balance"

        # Function to test max receivable calculation
        test_max_receivable_calculation() {
          local extension_name="$1"
          echo "üîç Testing max receivable calculation for $extension_name..."

          # Check if the extension is installed and accessible
          if curl -s "http://localhost:5001/$extension_name" | grep -q "Taproot Assets\|taproot"; then
            echo "‚úÖ $extension_name extension is accessible"

            # Try to get asset data from the API
            echo "üì° Fetching asset data from API..."
            ASSET_API_RESPONSE=$(curl -s "http://localhost:5001/$extension_name/api/v1/taproot/listassets" \
              -H "X-Api-Key: $LNBITS1_ADMIN_KEY" 2>/dev/null || echo "API_FAILED")

            if [ "$ASSET_API_RESPONSE" != "API_FAILED" ] && echo "$ASSET_API_RESPONSE" | jq -e '.success' >/dev/null 2>&1; then
              echo "‚úÖ Successfully retrieved asset data from API"

              # Extract asset with channel info
              ASSETS_WITH_CHANNELS=$(echo "$ASSET_API_RESPONSE" | jq -r '.data[] | select(.channel_info != null)')

              if [ -n "$ASSETS_WITH_CHANNELS" ] && [ "$ASSETS_WITH_CHANNELS" != "null" ]; then
                echo "$ASSETS_WITH_CHANNELS" | jq -c '.' | while IFS= read -r asset; do
                  echo "üîç Analyzing asset channel data..."

                  # Extract channel information
                  CAPACITY=$(echo "$asset" | jq -r '.channel_info.capacity // 0')
                  LOCAL_BALANCE=$(echo "$asset" | jq -r '.channel_info.local_balance // 0')
                  REMOTE_BALANCE=$(echo "$asset" | jq -r '.channel_info.remote_balance // 0')
                  ASSET_ID=$(echo "$asset" | jq -r '.asset_id // "unknown"')
                  PEER_ALIAS=$(echo "$asset" | jq -r '.channel_info.peer_alias // "unknown"')

                  echo "   Asset ID: $ASSET_ID"
                  echo "   Peer: $PEER_ALIAS"
                  echo "   Capacity: $CAPACITY sats"
                  echo "   Local Balance: $LOCAL_BALANCE sats"
                  echo "   Remote Balance: $REMOTE_BALANCE sats"

                  # Calculate what the UI would show vs what it should show
                  BUGGY_MAX_RECEIVABLE=$((CAPACITY - LOCAL_BALANCE))
                  CORRECT_MAX_RECEIVABLE=$REMOTE_BALANCE

                  echo "   üêõ Buggy calculation (capacity - local): $BUGGY_MAX_RECEIVABLE sats"
                  echo "   ‚úÖ Correct calculation (remote_balance): $CORRECT_MAX_RECEIVABLE sats"

                  # Check if the bug exists (values are different)
                  if [ "$BUGGY_MAX_RECEIVABLE" != "$CORRECT_MAX_RECEIVABLE" ]; then
                    echo "   üö® BUG DETECTED: Max Receivable calculation is incorrect!"
                    echo "   üìä The UI template uses: capacity - local_balance = $BUGGY_MAX_RECEIVABLE"
                    echo "   üéØ But it should use: remote_balance = $CORRECT_MAX_RECEIVABLE"
                    echo "   üí° Difference: $((BUGGY_MAX_RECEIVABLE - CORRECT_MAX_RECEIVABLE)) sats"

                    # This is expected if there are fees or if the channel isn't perfectly balanced
                    if [ $((BUGGY_MAX_RECEIVABLE - CORRECT_MAX_RECEIVABLE)) -gt 1000 ]; then
                      echo "   ‚ö†Ô∏è WARNING: Large discrepancy detected (>1000 sats)!"
                      echo "   This indicates the max receivable calculation bug is present"
                    else
                      echo "   ‚ÑπÔ∏è Small discrepancy - likely due to fees or reserves"
                    fi
                  else
                    echo "   ‚úÖ Max receivable calculation appears correct"
                  fi

                  echo ""
                done
              else
                echo "‚ÑπÔ∏è No assets with channel information found"
              fi
            else
              echo "‚ö†Ô∏è Could not fetch asset data from API"
              echo "API Response: ${ASSET_API_RESPONSE:0:200}..."
            fi
          else
            echo "‚ö†Ô∏è $extension_name extension not accessible"
          fi
        }

        # Test the taproot_assets extension
        test_max_receivable_calculation "taproot_assets"

        # Also check if the template calculation matches what we expect
        echo "üîç Checking frontend template calculation..."
        if [ -f "lnbits*/extensions/taproot_assets/templates/taproot_assets/index.html" ]; then
          TEMPLATE_CALC=$(grep -n "Max Receivable" lnbits*/extensions/taproot_assets/templates/taproot_assets/index.html | head -1)
          if echo "$TEMPLATE_CALC" | grep -q "capacity.*local_balance"; then
            echo "üêõ TEMPLATE BUG CONFIRMED: Template uses capacity - local_balance"
            echo "   Found: $TEMPLATE_CALC"
            echo "   üéØ Should use: remote_balance instead"
          elif echo "$TEMPLATE_CALC" | grep -q "remote_balance"; then
            echo "‚úÖ Template calculation appears correct (uses remote_balance)"
          else
            echo "‚ÑπÔ∏è Template calculation method unclear"
          fi
        fi

        echo -e "\n‚úÖ Max Receivable bug detection test complete!"

    - name: Cleanup
      if: always()
      run: |
        echo "=== Cleaning up containers ==="
        docker compose down -v
        
        # Clean up HTTPS proxy
        docker stop github-lnbits-proxy 2>/dev/null || true
        docker rm github-lnbits-proxy 2>/dev/null || true
        
        echo "‚úÖ Cleanup complete"